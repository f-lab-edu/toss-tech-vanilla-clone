[
  {
    "key": "firesidechat_frontend_2",
    "title": "모닥불 | EP.2 함수형 프로그래밍, 프론트엔드 개발에 진짜 도움 될까?",
    "subtitle": "토스 프론트엔드 개발자들은 함수형 프로그래밍 (Functional Programming) 과 객체 지향 프로그래밍 (Object-Oriented Programming) 중 어떤 것을 더 선호할까요?",
    "publishedTime": "2024-07-01T22:55:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/photos/modakbul2-1.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/photos/modakbul2-1.png"
    },
    "editor": {
      "name": "토스 프론트엔드 챕터",
      "shortDescription": null
    },
    "shortDescription": "\n여러분은 함수형 프로그래밍 (Functional Programming) 과 객체 지향 프로그래밍 (Object-Oriented Programming) 중 어떤 것을 더 선호하시나요?\n토스 프론트엔드 개발자들은 어떤 개발 패러다임을 선호할까요?\n\"FP는 무결함을 추구하는 것 같아요\"\n\"OOP는 의식주같지만, FP는 공부나",
    "fullDescription": "\n여러분은 함수형 프로그래밍 (Functional Programming) 과 객체 지향 프로그래밍 (Object-Oriented Programming) 중 어떤 것을 더 선호하시나요?\n토스 프론트엔드 개발자들은 어떤 개발 패러다임을 선호할까요?\n\"FP는 무결함을 추구하는 것 같아요\"\n\"OOP는 의식주같지만, FP는 공부나 운동처럼 필수재는 아닌 것 같아요\"\n치열했던 토론의 현장으로 여러분을 초대합니다.\n\n타임스탬프\n01:24 토스 개발자들이 함수형을 공부한 배경과 첫인상\n05:05 함수형 vs. 객체지향?\n10:39 함수형과 객체지향의 장점과 특징\n13:14 프론트엔드에서 객체지향 활용하기\n14:50 함수형과 객체지향의 매력과 재미\n17:33 프론트엔드 객체지향에 대한 사실과 오해\n\n출연진\n박서진, 토스 Head of Frontend\n문동욱, 토스 Frontend Developer Lead\n이성준, 토스 Frontend Developer Lead\n\n다른 모닥불 회차 보러가기\n📌EP.1 토스에서 말하는 “가독성 좋은 코드” 란 무엇일까?\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "생산성"
        },
        {
          "content": "Frontend"
        },
        {
          "content": "접근성"
        }
      ]
    }
  },
  {
    "key": "ssr-server",
    "title": "SSR 서버 최적화로 비용 아끼기",
    "subtitle": "오늘은 SSR 아키텍처 운영을 위해 반드시 알아두어야 할, SSR 서버의 최적화와 관련된 이야기를 해보려 합니다. 최적화를 통해 토스는 서비스 운영에 필요한 SSR 서버의 수를 절감하여 비용을 개선할 수 있었습니다.",
    "publishedTime": "2024-06-26T09:58:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/cpu-04.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/cpu-04.png"
    },
    "editor": {
      "name": "정진우/문현경",
      "shortDescription": "토스 Frontend Platform Engineer"
    },
    "shortDescription": "최근 프론트엔드 개발에서 사실상의 표준으로 자리매김 하는 기술이 있습니다. 바로 SSR, Server Side Rendering인데요. Next.js를 비롯한 다양한 프레임워크에서 SSR을 손쉽게 구축할 수 있는 솔루션을 제공하고 있습니다. 토스 또한 SSR을 도입하여 많은 사용자에게 빠르고 안정적인 경험을 제공하려고 노",
    "fullDescription": "최근 프론트엔드 개발에서 사실상의 표준으로 자리매김 하는 기술이 있습니다. 바로 SSR, Server Side Rendering인데요. Next.js를 비롯한 다양한 프레임워크에서 SSR을 손쉽게 구축할 수 있는 솔루션을 제공하고 있습니다. 토스 또한 SSR을 도입하여 많은 사용자에게 빠르고 안정적인 경험을 제공하려고 노력하고 있는데요.\n오늘은 SSR 아키텍처 운영을 위해 반드시 알아두어야 할, SSR 서버의 최적화와 관련된 이야기를 해보려 합니다. 최적화를 통해 토스는 서비스 운영에 필요한 SSR 서버의 수를 절감하여 비용을 개선할 수 있었습니다.\nSSR이란?\nSSR은 Server Side Rendering의 약자로, 화면의 렌더링이 서버에서 이루어지는 아키텍처를 의미합니다. 사전적인 의미는 이러하지만 일반적으로 현대의 SSR은 “첫 HTML 렌더링을 서버에서 처리하고, 이후의 렌더링 사이클은 클라이언트에서 처리”하는 하이브리드 형태의 SSR을 가리킵니다. Next.js, Astro 등의 현대적인 웹 프레임워크는 기본적으로 제공하는 아키텍처입니다. Static Site Generation이나 Dynamic SSR처럼 다양한 방식이 있습니다.\nSSR은 “첫 HTML 렌더링을 서버에서 처리”하기 때문에, 사용자의 화면에 컨텐츠가 그려지는데 걸리는 시간(FCP, First Contentful Paint)가 더 짧습니다. 토스는 이전에 CSR(Client Side Rendering) 아키텍처를 사용하고 있었는데요. 사용자의 화면에 JavaScript 번들이 모두 다운로드된 다음 첫 렌더링을 실행하면서 인증, 데이터 요청 등의 과정을 거치다보니 화면이 렌더링되는 시간이 상대적으로 길었습니다.\n\n이때 SSR 아키텍처를 도입하게 되면서, 인증과 데이터 처리의 첫 과정이 서버에서 먼저 모두 이루어진 다음 사용자는 완성된 HTML을 받아보면서 로딩 속도를 상당히 감축할 수 있었습니다.\n\n\n하지만 공짜 점심은 없죠. SSR을 도입하면 SSR 서버를 구축해야 합니다. Static Serving으로 처리가 가능한 CSR 아키텍처에서는 별도의 로직을 구현하는 서버를 만들 필요가 없습니다. 요청자가 요청한 위치의 파일을 돌려주기만 하면 됩니다. 하지만 SSR은 요청에서 필요한 정보를 파악하고, 적절한 페이지 파일을 가져와 렌더링을 처리한 후, 완성된 HTML과 JS 번들을 돌려주어야 합니다. 다행히 토스에서 사용하는 Next.js는 SSR 서버 구축을 아주 쉽게 할 수 있도록 도와줍니다. 토스 앱의 동작에 필요한 몇몇 미들웨어와 라우팅 로직을 커스텀 서버에 구현하는 정도로 마무리할 수 있었으니까요.\n// 서드파티 Server Framework(e.g. Express)를 사용할 수도 있습니다.\n// Next.js에 기본적으로 내장된 서버는 built-in http module을 사용합니다.\nconst { createServer } = require('http')\nconst next = require('next')\nconst app = next({ dev, hostname, port })\nconst handle = app.getRequestHandler()\n \napp.prepare().then(() => {\n  createServer(async (req, res) => {\n    // 여기서 Next.js의 handle을 처리하게 됩니다.\n  })\n    .once('error', (err) => {\n      console.error(err)\n      process.exit(1)\n    })\n    .listen(port, () => {\n      console.log(`> Ready on http://${hostname}:${port}`)\n    })\n})\n그러나 서비스의 성장에 따라 SSR 서버로 유입되는 트래픽이 늘어나면서, 서버의 숫자도 상당히 늘어나게 되었습니다. 또한 SSR 아키텍처의 빠른 로딩이라는 이점을 위해 SSR을 도입하는 서비스의 숫자도 점점 늘어났습니다. 이에 따라 SSR 서버의 숫자가 관리하기 어려울 만큼 많아졌고, 이들의 숫자를 줄여야 한다는 문제 의식이 발생합니다. 트래픽을 줄일 수는 없기 때문에, 같은 트래픽에서 서버의 숫자를 감축하는 것은 한 대의 서버가 감당할 수 있는 최대 트래픽의 수를 늘린다는 뜻이 됩니다.\n\nSSR 서버 성능 측정하기\n“측정”은 성능 개선 작업에 매우 필수적인 요소이자, 실제 개선보다도 어쩌면 더욱 중요한 부분입니다. 가장 먼저 저희 팀은 SSR 서버의 성능을 반복적으로 측정할 수 있는 환경을 마련하는데 집중했는데요. 프론트엔드 개발팀에서 서버 성능에 집중적으로 투자하는 첫 경험이다보니 여러 시행착오가 있었습니다. 이를 보완하기 위해 서버 플랫폼 팀과 주기적인 미팅을 진행하여 서버 운영 및 성능 측정에 필요한 다양한 노하우를 공유받았고, 성공적으로 성능 최적화의 기반을 마련할 수 있었습니다.\n변인 통제하기\n컨테이너는 격리된 환경이니 성능에 영향을 주는 요소가 덜할 것이라고 착각할 수 있습니다. 하지만 컨테이너 또한 프로세스이기 때문에, 해당 프로세스가 실행되는 호스트 환경에 따라 성능의 차이를 가질 수 있습니다. 처음 저희 팀은 개발 서버의 K8S 클러스터에 SSR 컨테이너를 배포하고 성능을 측정했는데요. 배포 시마다 성능이 달라지는 현상을 겪었고 DevOps팀과 확인 했습니다. 그 결과 개발 서버의 Pod Scheduling에 특별한 제한이 없어서, Pod이 어떤 Node에 배치되는지에 따라 성능에 편차가 발생할 수 있다는 사실을 알았습니다.\n\n이 그래프는 소스코드의 아무런 수정없이 재배포 전후로 성능을 테스트한 결과입니다. 성능이 거의 2배 가까이 차이가 나는 것을 볼 수 있는데요. Pod이 얼마나 여유로운 Node에 배치되는지에 따라 성능 차이가 극심하게 발생할 수 있고, 이런 상황에서는 정상적인 변인 통제와 신뢰할 수 있는 성능 측정이 어려워집니다.\n따라서 EC2 스팟 인스턴스를 하나 두고 해당 인스턴스에는 성능 측정만을 위한 Pod을 배포하도록 수정했습니다. 격리된 환경은 반복적인 배포에서도 서비스 소스코드의 변경을 제외한 어떠한 다른 변인도 존재하지 않기 때문에, 수정된 코드가 성능에 어떻게 영향을 미치는지 투명하게 확인할 수 있는 매우 중요한 환경이 됩니다.\n\nRPS 이해하기\nRPS, Request Per Second(혹은 TPS)는 서버의 트래픽 소화 능력을 확인하는 가장 중요한 지표입니다. 정해진 시간 내에 얼마나 많은 양의 요청을 처리할 수 있는지 나타내는 값인데요. 따라서 이 값이 높을 수록 더 적은 서버로 더 많은 트래픽을 감당할 수 있게 됩니다. 일반적으로 테스트 환경에서는 테스트 프로그램을 사용해 Maximum RPS를 쏟아 부어서 서버의 최대 트래픽을 확인하는 방식을 사용합니다. \n처음 성능 측정을 진행할 때는 이 Max RPS만 보고, CPU 등 다른 리소스 사용량의 변화를 제대로 측정하지 않는 실수가 있었습니다. 서버의 비용과 갯수는 결국 리소스의 사용량으로 환산되기 때문에, 같은 트래픽 대비 리소스 사용량의 절감을 반드시 확인해야 합니다. Max RPS를 2배 향상시켰지만 리소스도 2배 더 사용한다면 적절한 의미의 비용 최적화라고 보기는 어려울 수 있습니다.\n추가적으로 RPS 측정 시 주의해야 하는 것이 있는데요. Maximum RPS를 넘어서는 트래픽에 대해 서버는 정상적인 응답을 할 수 없게 됩니다. 일반적으로는 Timeout이 발생하는데, 이렇게 서버가 비정상 응답을 돌려주는 시점의 트래픽 부하를 Max RPS로 볼 수 있습니다. 이때, 내가 측정 중인 성능이 테스트 대상 서버의 것인지 아니면 측정 프로그램의 것인지 착각하면 안됩니다. 측정 프로그램이 만들어낼 수 있는 부하보다 서버가 수용할 수 있는 한계가 더 높다면 정상적인 측정이 이루어지지 않습니다. \n저희 팀은 Grafana팀이 제작한 K6을 사용해 성능을 측정했는데요. JavaScript로 테스트 스크립트를 작성할 수 있으며 다양한 테스트 시나리오 설정을 제공하여 유연하고 정확한 성능 측정이 가능했습니다.\n\nEvent Loop 매트릭\nCPU나 메모리 사용 이외에도 Node.js에 특화된 매트릭도 확인해야 합니다. 일반적으로 가장 널리 알려진 것은 Event Loop Lag와 Event Loop Utilization입니다. 모두 Event Loop와 관련된 매트릭인데요. Event Loop은 주기적으로 메인 스레드를 점유하여 대기 중인 task를 처리합니다. 이때, 메인 스레드가 다른 작업으로 인해 점유되어 Event Loop가 대기하는 시간이 길어지는 것을 Event Loop Lag로 표현합니다. Lag이 높다면 특정한 작업이 메인 스레드를 오래 점유(block)하고 있다는 것으로, Node.js의 Event Loop 패턴을 적극적으로 활용하지 못하고 있다는 뜻이 됩니다. 마찬가지로 Event Loop Utilization은 Event Loop가 얼마나 바쁘게 작업을 하고 있는지 나타냅니다. 0과 1 사이의 값을 갖는데, 1에 가까울 수록 Event Loop가 쉬는 시간 없이 항상 어떤 작업을 처리하고 있다는 뜻이 됩니다. 만약 서버가 이미 Max RPS에 도달하여 더 이상의 트래픽을 받지 못하고 있는데, Event Loop Utilization이 1보다 낮은 상태라면 Loop를 꽉 채워 사용하지 못하고 있다는 뜻이 됩니다.\nEvent Loop Uitilization은 비교적 최근에 등장한 개념입니다. 이 매트릭의 등장 배경은 Introduction to Event Loop Utilization in Node.js 아티클에 더욱 심도있게 소개되어 있습니다.\n반복 측정\n다양한 수정사항이 지금 이 순간에도 서비스에 반영됩니다. 이는 곧 성능의 변동을 의미하기도 합니다. 만약 성능이 조금씩 하락하는 것을 눈치채지 못하고 있다가 어느 순간 이를 개선하려 한다면, 어디서부터 개선을 시도해야 하는지 막막할 겁니다. 따라서 변동사항이 있을 때 벤치마크를 통해 성능의 하락과 증가를 확인하는 것은 실질적인 최적화만큼이나 중요한 과제입니다. 저희 팀은 상기한 격리 환경과 매트릭 측정을 PR 머지 시마다 진행하도록 만들어서, 매번 서비스에 변경사항이 있을 때마다 성능의 변화를 그래프로 나타내도록 만들었습니다.\n\n최적화와 Profiling\n측정 환경이 모두 마련되었다면, 이제부터는 성능 저하의 의심 지점이나 개선 가능한 지점을 파악하고 하나씩 개선해볼 차례입니다. 저희 팀은 먼저 아키텍처를 몇몇 굵은 컴포넌트 단위로 쪼개고, 각각의 컴포넌트가 도입될 때마다 순정 상태로부터 얼마나 성능 하락이 발생하는지를 측정했습니다. 이 과정은 CPU Profiling을 이용하여 어떤 작업이 얼마 동안 메인 스레드를 점유하고 있는지 확인하는 방식으로 처리됩니다. \nOpentelemetry 추적\nNext.js는 OpenTelemetry를 사용해, 렌더링 과정에서 발생하는 오버헤드 퍼포먼스를 측정할 수 있습니다. 그런데 이 기능은 최신 버전에서만 제공되고 있고 현재 저희 팀에서 사용 중인 버전에는 제공되지 않았습니다. 최신 버전에 수정된 hook을 직접 현재 사용중인 버전에 삽입한 후 아래와 같이 매트릭을 측정했습니다.\n이를 통해, 몇몇 부분에서 성능 저하가 발생하고 있음을 확인했습니다. 개선된 부분 중 몇 가지 사례를 소개합니다.\nPrefetch와 Serializing\n위에 설명한 Opentelemetry로 SSR 서버의 성능을 확인하면 getInitialProps 단계에서 매우 많은 시간이 소요되는 것을 알 수 있습니다. getInitialProps는 페이지 렌더링 전에 필요한 데이터를 가져오는 작업을 수행하는데요.\n\n토스 프론트엔드는 React Query를 통해 Remote 데이터를 가져오고 있습니다. 이때 SSR 환경에서 prefetch된 데이터는 serializer를 통해 전달 가능한 형태로 변환된 후, 클라이언트에서 hydration을 거칠 때 다시 인스턴스화 됩니다. 이 작업은 Date 객체 등 곧바로 스트림이 불가능한 데이터 형식을 위해 삽입된 레이어인데요. 데이터 형식에 관계없이 serializer가 항상 진행되다보니 SSR 렌더링 과정에서 적지 않은 오버헤드를 차지하고 있었습니다.\n저희 팀은 이 serializer를 아예 없애기로 했습니다. 이 작업은 React Query의 queryClient cache를 hydrate 하기 위해 필요한데, 이 cache 자체가 serialize 가능한 형식이 되도록 바꾸면 serializer가 개입하는 단계를 삭제할 수 있습니다.\nyarn 버전 업데이트\n저희 팀은 yarn 3.2.4 버전과 pnp linker를 사용하고 있었는데요. pnp는 런타임에서도 모듈을 불러오고 해석하는 역할을 맡게 됩니다. 그런데 Profiler를 통해 모듈이 resolve되는 과정을 조사하던 중 이미 resolve된 Module에 대해 다시 import할 때 불필요한 오버헤드가 발생하고 있는 것을 발견했습니다. 이로 인해 SSR 서버의 성능이 다소 하락할 수 있었고, 최신 yarn을 설치했을 때는 발생하지 않는 것으로 보아 중간의 어떤 yarn 업데이트에서 해소된 적이 있었다는 것을 파악했습니다.\n\n그래프를 보면 3.6.1에서 극적인 성능 개선이 발생했다는 것을 알 수 있습니다. 실제로는 서비스 구현에 따라 변화의 정도에 차이가 있겠지만 상당히 큰 개선인 것은 분명한데요. 이는 yarn pnp가 기존에 캐싱된 Module을 즉시 사용하지 않고 모듈에 대한 resolve를 재차 진행하는 불필요한 오버헤드를 갖고 있었기 때문이었습니다.\n이 문제는 yarn 3.6.1에서 해결되었고, 저희 팀도 yarn 버전을 3.x 최신으로 업데이트하여 오버헤드를 제거할 수 있었습니다. \nExpress 제거\n또 다른 Next.js의 custom 서버에서 Express를 제거하는 일이었습니다. Express는 Node.js로 서버를 구성할 때 가장 많이 사용되는 프레임워크입니다. 그러나 토스 프론트엔드의 Next.js SSR 서버의 요구사항에 비해 다소 과한 기능들을 가지고 있었고, 미들웨어 등의 아키텍처가 오버헤드를 만들고 있습니다.\n\n그래서 Express와 관련된 모든 코드를 제거하고 Node.js 내장 http 서버를 사용하는 패턴으로 변경하였고, CPU 사용량을 대략 4~5%p 낮출 수 있었습니다.\n개선 결과\n상기한 지점 이외에도 크고 작은 개선점들이 추가로 있었고, 종합적으로 CPU 사용률을 평균적으로 20% 가까이 줄임으로서 서버의 대수도 비례해서 줄일 수 있었습니다.\n\n교훈\n브라우저 JavaScript를 개발할 때와 서버 사이드 JavaScript를 개발하는 것은 비슷하지만 조금은 다른 특성을 갖고 있습니다. 브라우저는 (탭을 영원히 열어두지 않는 이상) 일시적인 프로세스가 활성화되고, 원격지로부터 코드를 받고, JavaScript 이외에 HTML과 CSS에 대해 염두해야 합니다. 한 편 서버 사이드 JavaScript는 반영구적으로 동작하는 프로세스, 네트워크와 호스트 환경에 대한 더욱 심도있는 이해, Node.js 등 사용 중인 런타임에 대한 이해가 매우 깊게 필요합니다. 이러한 이해를 바탕으로 성능을 측정할 수 있는 환경까지 마련된다면, 최적화는 어려운 일이 아닙니다. 그래서 만약 Node.js SSR 서버의 성능을 개선하고 싶다면, 다음의 과정을 한 번 고민해보시면 좋겠습니다.\n현재의 런타임은 어떻게 구성되어 있는가? 네트워크 토폴로지는 어떻게 구성되어 있으며, 어떤 요청이 오가는가?\n측정이 필요한 성능은 무엇이 있는가? 측정할 수 있는가?\n개선 전후를 확인할 수 있는, 변인이 통제된 재현 환경이 존재하는가?\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SSR"
        }
      ]
    }
  },
  {
    "key": "secure-efficient-ai",
    "title": "토스뱅크가 AI로 보안과 효율도 챙기는 방법",
    "subtitle": "은행 창구에서 본인확인을 위해 뭘 요구할까요? 바로, 신분증입니다. 비대면 은행인 토스뱅크는 ML 모델로 어떻게 신분증 검증 과정의 수기 작업을 최소화했는지 알려드릴게요.",
    "publishedTime": "2024-06-20T18:09:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/cover-tech-0620.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/cover-tech-0620.png"
    },
    "editor": {
      "name": "김경윤",
      "shortDescription": "토스뱅크 Server Developer"
    },
    "shortDescription": "안녕하세요, 토스뱅크 Server Developer 김경윤입니다.\n은행 창구에서 본인확인을 위해 뭘 요구할까요? 바로, 신분증입니다! 비대면 은행인 토스뱅크에서도 서비스를 사용하려면 신분증이 가장 먼저 필요해요. 비대면 은행은 스마트폰으로 촬영된 신분증 이미지를 확인해서 위조 신분증인지 아닌지, 혹은 주요한 정보들이 잘 ",
    "fullDescription": "안녕하세요, 토스뱅크 Server Developer 김경윤입니다.\n은행 창구에서 본인확인을 위해 뭘 요구할까요? 바로, 신분증입니다! 비대면 은행인 토스뱅크에서도 서비스를 사용하려면 신분증이 가장 먼저 필요해요. 비대면 은행은 스마트폰으로 촬영된 신분증 이미지를 확인해서 위조 신분증인지 아닌지, 혹은 주요한 정보들이 잘 보이는지 확인할 의무가 있는데요. 이 작업은 사람이 모든 건을 일일이 확인하며 판단해야 해요.\n토스뱅크는 다양한 곳에서 AI 기술을 활용하고 있어요. 오늘은 신분증 검증 과정에서 ML 모델로 어떻게 수기 작업을 최소화했는지 알려드릴게요.\n토스뱅크 ML 모델의 진화\n신분증을 제출하면, 신분증을 검증한 다음에 계좌가 개설되는 것이 일반적이에요. 하지만 토스뱅크에서는 빠르고 편리한 고객 경험을 위해 계좌를 먼저 개설하고 그 이후에 신분증을 검사하는 사후 검증 방식을 선택했어요. 하지만 이 방식에는 신분증 위조나 금융 범죄가 일어날 수 있어요. 토스뱅크는 이런 ML 모델을 적극적으로 활용하며 이런 사고를 방지하고 있어요. 사고가 발생하기 전에 미리 이상 케이스를 탐지해서 거래를 막는 것이죠. \n앞서 SLASH 23에서 AI와 함께 가짜 신분증 찾아내기 주제로 발표한 적이 있는데요. ‘가짜 신분증 찾기’는 토스뱅크의 신분증 검증에 일부일 뿐이에요. 가짜 신분증을 걸러내는 것뿐만 아니라 신분증의 개인 정보가 잘 보이는지, 증명사진에서 얼굴이 잘 식별되는지 등의 기준도 함께 확인하고 있어요. \n\n이전에는 사람이 신분증을 종합적으로 검증했어요. 하지만 토스뱅크의 고객이 늘어나면서 신분증의 양도 늘어났고, 검증에 소요되는 시간과 비용을 줄이기 위한 방법이 필요했어요. 이에 따라 가짜 신분증을 찾아내는 ML 모델과 더불어, 신분증의 개인 정보를 추출하는 모델, 얼굴을 인식하는 모델 등을 추가했어요. 이렇게 다양한 모델을 활용해 종합적으로 신분증으로 검증하는 “신분증 사본 품질 검사 서비스”를 실제 토스뱅크에 도입하기 시작했고요.\n오늘은 해당 서비스가 토스뱅크에 어떻게 활용되고 있는지 알려드릴게요.\n기준에 부합하지 않은 신분증 반려\n고객이 제출한 신분증이 토스뱅크의 검증 기준에 적합하면 승인되고, 결격 사유가 있다면 반려돼요. 신분증이 반려된 고객은 다시 신분증 사진을 제출할 수 있도록 도와드려요. 신분증 승인은 아직 사람이 최종적으로 검증하지만, 사람이 보는 신분증의 양을 줄이기 위해 신분증 “반려” 과정을 자동화했어요. “신분증 사본 품질 검사 서비스” 모델로 사용자가 제출한 신분증이 토스뱅크의 검증 기준을 만족하는지 확인한 것이죠.\n해당 모델에는 이미지 분류 모델, 객체 탐지 모델 등 다양한 모델이 각 검증 기준에 대한 점수를 0과 1 사이의 값을 계산해요. 0에 가까울수록 정상 신분증에 가깝다고 판단한 것이고, 1에 가까울수록 반려해야 할 신분증에 가깝다고 판단한 거죠. 0과 1 사이에 임계값(thershold)을 설정하고, 모델이 예측한 결과가 해당 임계값을 넘으면 신분증을 반려하는 시스템입니다. \n임계값 설정하기\n하지만 임계값을 어떻게 설정해야 될까요?\n먼저 모델을 평가하는 방법을 설명드릴게요. 모델이 기준에 부합하지 않은 신분증 반려하지 않은 경우를 False Negative라고 해요. False Negative가 많으면 사람의 수기 검증을 효율적으로 줄이지 못하죠. 반면 모델은 “검증 기준에 부합하지 않는 잘못된 신분증이야!”라고 판단하여 신분증을 반려했지만, 실제로 정상적인 신분증인 경우를 False Positive라고 해요. False Positive가 많으면 선량한 고객이 불편을 겪어요.\n\n임계값이 너무 낮다면 많은 고객의 신분증이 반려되는 False Positive가 많을 테고, 임계값이 너무 높다면 False Negative가 늘어나요. 즉, False Negative와 False Positive 사이에는 트레이드오프가 존재해요. 따라서 모델의 성능뿐만 아니라 비즈니스 요구사항과 시간, 비용과 같은 자원을 고려해서 적절한 임계값을 설정하는 것이 중요해요.\n저희는 고객이 모델의 잘못된 판단으로 신분증을 반려하면 사용자는 신분증 사진을 다시 제출할 때까지 토스뱅크를 이용할 수 없는 불편함을 최소화하는 것을 목표였어요. 신분증 반려 자동화에 False Positive를 최소화하고 싶었어요. 그래서 토스뱅크는 고객의 경험을 위해 False Positive를 0에 가깝게 설정할 수 있는 임계값을 실제 서비스에 사용하기로 결정했어요.\n모델 평가하기\n\n하지만 False Positive만 최소화하면 그만큼 수기 검증이 필요한 신분증이 늘어나죠. 그래서 이를 개선하기 위해 False Negative를 최소화하는 또 다른 임계값을 설정했어요. 이 두 번째 임계값은 실제 서비스에서 사용하지 않지만, 모델의 성능과 고객 경험을 측정하는 데 사용하는 것이죠.\n해당 임계값보다 모델 점수가 높은 경우에는 관리자 화면에 위와 같이 경고 메시지를 띄워 수기 검증을 보조하고 있어요. 두 번째 임계값에 따라 확실하게 문제가 있다고 판단되는 경우에는 자동으로 반려해서 수기 작업량을 최소화하고, 조금 의심되는 경우에는 관리자에게 경고 메시지를 띄워서 잘못 판단하여 놓치는 경우를 최소화했어요.\n\n최종적으로 사용된 임계치를 도식화하면 위와 같아요. REJECT_THRESHOLD 보다 점수가 높다면, 그 신분증은 즉시 반려가 되고,REJECT_THRESHOLD보다 낮지만, REJECT_WARNING_THRESHOLD 보다 점수가 높으면, 관리자에게 경고하여 도와줘요. 이외에는 기존과 같이 관리자가 직접 검토해요.\n\n신분증 촬영본 사전검증\n앞서 설명드린 사후 검증 과정에서 신분증이 반려된다면, 고객은 또 신분증을 제출하고 검증 승인을 기다려야 돼요. 그동안 토스뱅크 서비스의 일부를 사용할 수 없고요. 이런 불편함을 최소화하기 위해서 검증이 시작되기도 전에 촬영된 신분증 사본이 문제가 있으면 고객에게 미리 알려주는 시스템을 구축했어요.\n고객이 신분증을 촬영한 순간, 이미지가 토스뱅크 기준을 만족하는지 확인하고 문제가 있다면 즉각적으로 사용자에게 알려 다시 촬영할 수 있도록 도와주는 것이죠. “신분증 사본 품질 검사 서비스” 모델을 사용해서 고객에게 문제점을 정확히 알려줄 수 있었어요.\nA/B 테스트로 검증하기\n이 때의 임계치 설정은 2가지 의견이 있었어요. \n사후 검증처럼 무겁지 않은데, 조금이라도 의심된다면 알려주자.\n사후 검증처럼 정말 확실한 것만 사용자에게 알려주자.\n어떻게 임계치를 설정하지에 대한 의견이 정말 많았지만, 토스의 코어 밸류인 Execution Over Perfection에 맞게 실험을 해보기로 했어요. 토스 사내 서비스 TUBA를 사용해서 빠르게 A/B 테스트를 환경을 세팅할 수 있었고, A/B 테스트 환경은 아래와 같이 설정했어요.\n성공 지표 \n신분증 촬영 단계 통과율\n신분증 사후 검증 반려율\n실험군\nControl - 모델을 사용하지 않음\nVariant A - False Negative를 최소화 한 임계치\nVariant B - False Positive를 최소화 한 임계치 + “문제가 반복되나요” 버튼이 없음\n\nA/B 테스트의 결과\n실험의 결과로 Variant A가 Winner로 선정되었어요.\nVariant A는 Control에 비해 약 1.5~2% 정도 신분증이 반려되는 비율이 낮았으며, 통과율이 그렇게 차이 나지 않았어요. Variant A와 B 사이에 통과율은 큰 차이가 없었고, A가 B에 비해 반려되는 비율이 더욱 적었어요. 촬영된 신분증에 문제가 있을 때, 정확히 문제점을 짚어서 피드백을 사용자에게 주면, 되도록 이탈하지 않고, 다시 촬영한다 라는 것을 알게 되었어요. \n\n그래서 현재 고객이 최종적으로 사용자가 만나고 있는 화면은 위와 같아요. 사용자가 찍은 신분증 이미지를 보여주고, 어느 부분이 문제인지 정확히 짚어서 설명해줘요. 또한, ML 모델의 지속적인 잘못된 판단으로 인하여 불편을 겪은 고객들은 “문제가 반복되나요?” 버튼을 통해 넘어갈 수 있어요.\n\n\n마무리\n신분증 검증 과정을 통해서 토스뱅크에서 ML 모델을 적극적으로 활용하여 보안과 효율을 챙긴 방법을 소개 드렸는데요. ML 모델을 실제 서비스에 적용하면서 임계값의 중요성을 다시 깨달았습니다. 고객의 편의를 해치지 않으면서도 서비스의 효율을 높이기 위해서는 목표를 정확히 설정하고, 목표에 적합한 임계치를 수차례의 실험을 통해 찾는 것이 중요합니다. 또한, 하나의 모델로 관리자를 위해, 고객을 위해 사용한 것 처럼, 다양한 곳에서 활용할 수 있다는 것을 잊지 마세요.\n많은 고객에게 혁신적인 은행 서비스와 신분증 검증과 같은 유연하고 확장 가능한 시스템을 설계하고 싶다면 토스뱅크에 합류하세요. \n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "AI"
        },
        {
          "content": "자동화"
        },
        {
          "content": "Server"
        },
        {
          "content": "Machine Learning"
        }
      ]
    }
  },
  {
    "key": "firesidechat_frontend_1",
    "title": "모닥불 | EP.1 토스에서 말하는 “가독성 좋은 코드” 란 무엇일까?",
    "subtitle": "모닥불 피워두고 같이 도란도란 이야기 나누는 것처럼, 토스 프론트엔드 개발자들은 '모닥불'이라는 시간을 통해 함께 기술적인 문제를 나누고 해결방안을 찾아가는데요. 최근 모닥불 중 가장 뜨거웠던 주제를 소개합니다.",
    "publishedTime": "2024-06-19T15:14:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/modakbul-thumbnail%20(1).png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/6.jpg"
    },
    "editor": {
      "name": "토스 프론트엔드 챕터",
      "shortDescription": null
    },
    "shortDescription": "\n\n여러분은 기술적인 고민을 누구와 나누시나요?\n모닥불 피워두고 같이 도란도란 이야기 나누는 것처럼, 토스 프론트엔드 개발자들은 '모닥불'이라는 시간을 통해 함께 기술적인 문제를 나누고 해결방안을 찾아가고 있는데요.\n최근 모닥불 중 가장 뜨거웠던 주제를 소개합니다.\n“코드란 비즈니스를 위한 수단이다\"\n\"퀄리티 높은 코드는",
    "fullDescription": "\n\n여러분은 기술적인 고민을 누구와 나누시나요?\n모닥불 피워두고 같이 도란도란 이야기 나누는 것처럼, 토스 프론트엔드 개발자들은 '모닥불'이라는 시간을 통해 함께 기술적인 문제를 나누고 해결방안을 찾아가고 있는데요.\n최근 모닥불 중 가장 뜨거웠던 주제를 소개합니다.\n“코드란 비즈니스를 위한 수단이다\"\n\"퀄리티 높은 코드는 동료를 위한 것이다\"\n토스 프론트엔드 헤드 서진님과 프론트엔드 개발자 유림님, 진우님이 '가독성 좋은 코드'란 무엇인지에 대해 나누는 이야기를 들어보세요.\n\n타임스탬프\n00:00 인트로\n01:13 코드 퀄리티, 꼭 챙겨야 할까?\n05:55 코드 퀄리티 덕분에 행복해진 경험\n09:06 ‘가독성’의 요소 정의\n16:23 코드 퀄리티를 챙기는 타이밍\n20:25 코드 퀄리티를 챙기는 꿀팁\n\n출연진\n박서진, 토스 Head of Frontend\n진유림, 토스 Frontend Developer\n정진우, 토스 Frontend Platform Engineer\n",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "생산성"
        },
        {
          "content": "Frontend"
        },
        {
          "content": "리팩토링"
        },
        {
          "content": "자동화"
        },
        {
          "content": "문화"
        }
      ]
    }
  },
  {
    "key": "monorepo-pipeline",
    "title": "200여개 서비스 모노레포의 파이프라인 최적화",
    "subtitle": "토스 프론트엔드 챕터에서는 하나의 모노레포에서 200여개가 넘는 서비스를 관리하고 있어요. 이렇게 커진 모노레포에서도 git push 부터 배포까지 5분을 유지할 수 있는 비결을 소개합니다!",
    "publishedTime": "2024-06-14T10:51:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-tech-organizing-cover.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-tech-organizing-cover.png"
    },
    "editor": {
      "name": "정석호",
      "shortDescription": "토스 Frontend Platform Engineer"
    },
    "shortDescription": "프론트엔드 모노레포\n모노레포는 여러 프로젝트나 라이브러리를 하나의 저장소에서 관리하는 단일 레포를 말합니다. 이를 통해 코드 공유와 의존성 관리가 용이해지고, 많은 개발자에게 일관된 개발 경험을 줄 수 있어요. 또한, 단일 저장소로 모든 프로젝트를 관리하기 때문에 CI/CD 설정을 같이 가져갈 수 있어서 편리해요.\n토스 ",
    "fullDescription": "프론트엔드 모노레포\n모노레포는 여러 프로젝트나 라이브러리를 하나의 저장소에서 관리하는 단일 레포를 말합니다. 이를 통해 코드 공유와 의존성 관리가 용이해지고, 많은 개발자에게 일관된 개발 경험을 줄 수 있어요. 또한, 단일 저장소로 모든 프로젝트를 관리하기 때문에 CI/CD 설정을 같이 가져갈 수 있어서 편리해요.\n토스 프론트엔드 챕터에서는 하나의 모노레포에서 200여개가 넘는 서비스를 관리하고 있어요. 이 레포의 기여자는 50~60명이며, 일평균 머지되는 PR은 평균 60개가 넘어요!\n이렇게 많은 서비스가 관리되면서 모노레포가 점점 커지게 되었고, 결국 레포를 단순히 클론받는 것 자체가 불가능한 경지까지 왔어요. 그래서 종종 필요하기 전까지 blob을 내려받지 않도록 filter=blob:none 을 애용하곤 합니다.\n\n토스에서는 이렇게 커진 모노레포에서도 git push 부터 배포까지 5분을 유지할 수 있었는데, 그 비결을 소개합니다!\n\n비법 1: 병렬화를 통한 CI/CD 속도 최적화\n모노레포에서는 여러 서비스가 동시에 변경되는 경우가 종종 있는데, 이때 서비스의 빌드는 1번이 아닌 N 수행됩니다. 토스 프론트엔드 챕터에서는 개발 , 스테이징 , 라이브 환경 빌드를 모두 따로 하고 있어서 (변경된 서비스의 수) x (빌드해야하는 환경의 수) 만큼 수행이 필요해요.\n한번 모노레포에서의 서비스 빌드는 얼마나 걸리는지 계산해 볼게요. 만약 쇼핑, 송금, 만보기와 같이 3개의 서비스에 변경이 발생했다면, 총 9번의 빌드를 하게 됩니다. 각 서비스가 CI/CD에서 빌드되는 시간을 5분이라고 가정할 때, 순차적으로 빌드한다면 총 45분이 걸리죠. \n3개 서비스 x 3개 환경 x 5분 빌드시간 = 45분\n이렇게 변경되는 서비스가 많을수록 빌드 시간이 더 오래 걸리고, 개발자는 더 많은 시간을 기다리거나 다른 작업을 하는 등 컨텍스트 스위칭 비용이 발생해요. 😢\nyarn을 쓰고 있다면, yarn workspace since run --jobs 옵션을 통해 빌드를 병렬로 수행할 수 있어요. 하지만 각 서비스가 빌드되는 환경이 하나의 컴퓨팅 환경이라면, CPU와 Memory와 같은 컴퓨팅 리소스를 공유하게 되는 문제가 있어요. 한정된 CPU와 Memory를 쓰는 환경에서, 병렬의 숫자를 늘리면 오히려 더 느려지게 됩니다. 결국 빌드 대상이 많아지면, 병렬을 해도 순차적으로 실행한 경우와 비슷한 시간이 소요됩니다.\n모든 빌드를 서로 독립된 환경에서 실행하도록 파이프라인을 고치면 이런 문제를 뿌리째 뽑을 수 있어요! 프론트엔드 챕터에서는 CircleCI의 Dynamic Configuration 을 이용해서 손쉽게 시도해 볼 수 있었습니다.\n\n\n이상적인 상황이라면, 서비스가 아무리 많아도 모든 서비스는 6분 내외로 모든 빌드가 완료됩니다.\n2개 서비스: 1분 (트리거 파이프라인) + 5분 (병렬 파이프라인)\n40개 서비스: 1분 (트리거 파이프라인) + 5분 (병렬 파이프라인)\n200개 서비스: 1분 (트리거 파이프라인) + 5분 (병렬 파이프라인)\n\n만약 돈이 무한하다면 시간을 무한으로 아껴볼 수 있지만, 현실적으로 최대 러너 수를 조절해서 파이프라인을 구성해야 비용도 아낄 수 있다는 점 잊지 말아 주세요!\n결국 저희는 2개 서비스 변경이 생겼을 때를 기준으로 약 5배 정도의 시간을 아낄 수 있어요.\nAS-IS: 2개 서비스(6개 배포): 6 * 5 = 30분\nTO-BE: 2개 서비스(6개 배포): 1 + 5 = 6분\n\nCircleCI뿐만 아니라 Jenkins를 통해서도 동적으로 파이프라인을 구성할 수 있습니다. \n\n이처럼 다양한 CI/CD의 기능을 통해 각 파이프라인을 독립된 컴퓨팅 환경에서 수행하는 것이 가장 중요합니다.\n\n비법 2: Daily Docker Base Image\n거대해진 모노레포의 사이즈는 40GB를 훌쩍 넘기고 있어요. 빌드가 실행되는 러너에서 이 레포를 매번 checkout 하려면 매우 오랜 시간이 걸리거나 타임아웃 오류가 발생해요.\n어떻게 하면 CI에서 오류를 내지 않으면서 checkout 시간을 줄일 수 있을까요?\n그 방법은 바로 모노레포를 미리 복제하기입니다. 미리 복제한 환경으로 빌드를 시작하면, 처음부터 git을 내려받을 필요가 없게 되어 오래 기다릴 필요도 없습니다! 2022년 SLASH 발표를 통해 잠깐 소개해 드렸던 내용인데요, 모노레포의 컨텐츠를 미리 도커 이미지로 구워 변경된 부분만 새로 받는 방법입니다.\n\n모노레포의 git 컨텐츠를 미리 굽는 방법은 Dockerfile을 다음과 같이 작성하여 간단하게 따라 해볼 수 있습니다.\nFROM docker.io/cimg/node:20.14.0\nSHELL [\"/bin/bash\", \"-c\"]\n\n# 중략\nWORKDIR ${HOME}/project\n\n# 가볍게 50개 커밋 내역만 먼저 clone 받기\nRUN git clone --depth 50 $CIRCLE_REPOSITORY_URL\n\n# 코드 변경 계산에 적당할 정도로 1000개 커밋 내역까지 이어서 내려받기\nRUN git fetch --depth 1000 --force origin main\n\n# 현재 환경을 main 브랜치로 설정\nRUN git checkout --force -B main\n\n# yarn install 미리 해두기 (생략 가능)\nRUN yarn\n위와 같은 Dockerfile을 매일 오전 7시 마다 동작하도록 예약해 두었습니다. 36분이 걸리는 것을 확인할 수 있습니다. 이를 통해 매번 빌드할 때마다 checkout을 해야 했다면 매번 36분씩 더 소요되는 것을 알 수 있어요!\n\n\n이렇게 만든 도커 이미지는 CircleCI의 executor를 이용해서 사용할 수 있어요. CircleCI의 executor를 간단하게 소개드리자면, 아래처럼 특정 이미지로 Job을 실행할 수 있는 설정을 말해요.\nversion: 2.1\nexcutors:\n  my-executor:\n    docker:\n      - image: cimg/ruby:3.0.3-browsers\njobs:\n  my-job:\n    executor: my-executor\n    steps:\n      - run: echo \"Hello executor!\"\n토스에서는 AWS ECR을 이용해서 Docker 이미지를 관리하고 있는데, 이걸 CircleCI executor로 쓰려면 다음과 같이 작성해 볼 수 있어요.\nexecutors:\n  toss_frontend_excutor:\n    docker:\n      - image: xxxxxx.dkr.ecr.ap-northeast-2.amazonaws.com/ci-base-image:latest\n        aws_auth:\n          aws_access_key_id: $AWS_ACCESS_KEY_ID\n          aws_secret_access_key: $AWS_SECRET_ACCESS_KEY\n        environment:\n          TZ: 'Asia/Seoul'\n          AWS_DEFAULT_REGION: ap-northeast-2\n          ECR_REGISTRY: xxxxxx.dkr.ecr.ap-northeast-2.amazonaws.com\n          ECR_REPOSITORY: ci-base-image\n          ECR_LATEST_TAG: 'latest'\n이 executor를 이제 Job에서 써볼까요?\njobs:\n  trigger-publish:\n    executor: toss_frontend_excutor\n    steps:\n      - trigger-publish-service\n미리 받은 컨텐츠 이후에 변경된 부분만 내려받는 시간을 확인해 보면 22초로 단축된 것을 확인할 수 있어요!\n\n이러한 방법을 통해 저희는 36분의 소요 시간을 22초로 줄일 수 있었습니다. git checkout이 필요한 모든 Job마다 약 36분 정도의 시간을 아낄 수 있어요!\n\n비법 3: SSR Standalone Docker Image\n마지막으로 소개해 드릴 내용은 SSR 배포 시간을 획기적으로 줄여주는 Standalone 모드입니다. 사실 눈치채신 분들도 계시겠지만, 이 부분도 2022년 SLASH 발표에서 한번 소개해 드린 적 있는 내용이에요.\n\nNode File Trace를 통해서 애플리케이션 런타임에 필요한 의존성만 뽑아낼 수 있는데, 최소한의 JavaScript 파일만 모아서 빌드 환경을 만들면 획기적으로 가벼워 Docker 빌드와 K8S로의 배포 시간이 빨라집니다.\n\n2년 전쯤부터 Next.js 에서 이러한 아이디어를 next.config.js 의 output: 'standalone' 으로 제공해 주고 있습니다. 더 자세한 내용은 automatically-copying-traced-files 공식 문서를 참고하세요.\n\n하지만 저희가 쓰기에는 한 가지 아쉬운 점이 있었는데요, 이 기능은 node_modules라는 특별한 디렉토리에 의존되어 있었어요. 저희는 Yarn PnP 를 사용해 node_modules 가 아닌 .yarn/cache라는 곳에 의존성이 저장되어서 이 기능을 그대로 사용할 수가 없었어요.\n토스가 Yarn을 쓰는 이유\nnode_modules로부터 우리를 구원해 줄 Yarn Berry\n패키지 매니저의 과거, 토스의 선택, 그리고 미래\n그래서 PnP API를 활용하여 Next.js standalone 기능과 비슷한 역할의 함수를 작성했습니다.\n실제로는 더 복잡하지만, 아이디어만 뽑아서 간단하게 모습을 보여드릴게요.\nasync function createSSRBundle(options: Options): Promise<SSRBundle> {\n  const context = getSSRBundleContext(options);\n  \n  // 필요한 파일과 의존성 계산\n  const [files, depFiles] = await Promise.all([\n\t  getFilesForSSRBundle(context),\n\t  getDependencyFiles(context),\n  ]);\n\n  // 엔트리 파일 추출\n  const fileEntries = createFileEntries([ ...files, depFiles ], context);\n  const pnpLoaderEntries = createPnPLoaderEntries(context);\n  const pnpEntries = createPnPEntries([ depFiles ], context);\n  \n  // 압축\n  const zip = new Zip();\n  await addEntriesToZip(zip, [\n    ...fileEntries,\n    ...pnpLoaderEntries,\n    ...pnpEntires\n  ]);\n  \n  return zip.toStream();\n}  \n위와 같은 함수를 통해 만든 bundle.zip파일은 SSR Dockerfile에서 활용할 수 있습니다.\nFROM node:20.11.1-alpine3.19\n\nWORKDIR /app\nCOPY ./bundle.zip ./bundle.zip\n\nRUN unzip -i ./bundle.zip -d workspace\n\nWORKDIR /app/workspace\nCMD node -r ./.pnp.cjs --experimental-loader ./pnp.loader.mjs ./server.js\n이제 bundle.zip만 있으면 어디서든 SSR 서버를 실행할 수 있어 git과 yarn이 없는 곳에서도 문제없이 서버를 띄울 수 있어요.\nSSR Docker Image의 사이즈도 4GB에서 약 200MB로 줄어들어 20배가량의 최적화를 이룰 수 있어요.\n\nSSR Docker Image의 사이즈는 배포 속도와도 관련이 있는데, 바로 Kubernetes에서 PodInitializing 시간을 감소시켜 줍니다. (PodInitializing란, K8S pod를 띄울 때 필요한 도커 이미지를 pull 하는 과정을 말해요)\n\n총 정리\n위에 소개해 드린 3가지의 비결을 통해 저희는 다음과 같은 최적화를 이룩할 수 있었어요\n병렬화를 통한 CI/CD 속도 최적화 → 배포 시간 5배 개선\nDaily Docker Base Image  → Job 당 36분 이상 개선\nSSR Standalone Docker Image → Pod 뜨는 시간 20배 개선\n오늘은 토스 프론트엔드 챕터에서 거대한 모노레포를 운영하면서 적용해 본 최적화 사례를 공유드렸어요. 이 최적화 방법들을 통해 여러분의 모노레포에서도 CI/CD 시간을 획기적으로 단축할 수 있을 거에요. 지금 바로 도입해 보세요!\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "frontent-package-migration",
    "title": "프로젝트 전체에서 사용되는 패키지, 어떻게 마이그레이션 할까?",
    "subtitle": "시간이 지날수록 그동안 잘 사용했던 기반 기술들이 더 이상 최선의 선택이 아닌 순간이 오는데요. 제품을 계속 안정적으로 운영하면서 마이그레이션 또한 쉽지 않습니다. 오늘은 토스의 TUBA 팀에서는 이런 문제를 어떻게 해결했는지 소개드릴게요.",
    "publishedTime": "2024-06-04T18:01:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/migration-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/migration-thumb.jpg"
    },
    "editor": {
      "name": "김덕원",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "프로젝트가 커지고 시간이 지날수록 그동안 잘 사용했던 기반 기술이 더 이상 최선의 선택이 아닌 순간이 와요. 이런 기술을 바꾸지 않고 방치하면 개발 측면에서는 빌드 시간 및 복잡도 증가, DX 하락 등 예측하기 어려운 여러 문제가 일어날 수 있어요. 개발 생산성이 떨어지고 제품 운영 및 개선의 발목을 잡기도 하고요.\n그렇",
    "fullDescription": "프로젝트가 커지고 시간이 지날수록 그동안 잘 사용했던 기반 기술이 더 이상 최선의 선택이 아닌 순간이 와요. 이런 기술을 바꾸지 않고 방치하면 개발 측면에서는 빌드 시간 및 복잡도 증가, DX 하락 등 예측하기 어려운 여러 문제가 일어날 수 있어요. 개발 생산성이 떨어지고 제품 운영 및 개선의 발목을 잡기도 하고요.\n그렇지만 제품을 안정적으로 운영하면서 기반 기술을 마이그레이션하기 또한 쉽지 않은데요. 오늘은 제가 속한 토스의 TUBA 팀에서는 이런 문제를 어떻게 해결했는지 소개드릴게요.\n토스의 만능 어드민, TUBA\nTUBA(Toss User Behavior Analyzer)는 2018년에 출시된 토스 임직원용 종합 데이터 솔루션이에요. TUBA에는 A/B 테스트, 메세지, 유저 세그먼트 등 총 22개의 하위 제품이 있어요. PO, PM, 디자이너, 개발자 외에도 Account Manager와 같은 비즈니스 직군, Customer Hero와 같은 고객 응대 직군까지 다양한 임직원이 매일 업무를 위해 사용하는 제품이에요!\n하지만 오래되고 큰 프로젝트인 만큼 TUBA에 여러 문제가 발생했는데요. \n첫 번째 시련: 너무 오래 걸리는 빌드\n첫 번째로는 빌드 속도가 매우 느려졌어요. TUBA는 yarn workspace를 활용해서 아래와 같이 frontend 하위 서비스와 frontend-common 공통 모듈을 나누어 관리하고 있는데요.\nfrontend\n├─ Service-A\n├─ Service-B\n└─ ...\nfrontend-common\n├─ components\n├─ containers\n├─ models\n└─ ...\n각 frontend 패키지가 frontend-common의 패키지를 사용하고 있어요.\n{\n  \"dependencies\": {\n    \"@tuba/components\": \"workspace:frontend-common/components\",\n    \"@tuba/containers\": \"workspace:frontend-common/containers\",\n    \"@tuba/models\": \"workspace:frontend-common/models\"\n  }\n}\n문제는 frontend-common에 있는 공통 코드를 수정하면 전체 프로젝트 코드의 최신화가 필요했어요. 그렇기 때문에 작은 코드 수정이 있어도 frontend 하위에 있는 22개의 서비스를 모두 새로 빌드해서 배포해야 됐죠.\n너무 많은 프로젝트를 동시에 빌드하다보니 메모리 이슈로 빌드가 실패하기 시작했어요. 우선 급한 빌드를 내보내야 하니 동시에 1개만 빌드되도록 변경했는데요. 무려 빌드 타임이 2시간 15분으로 나왔어요.\n\nNext 제거 의사결정\n느린 빌드 타임의 원인을 파악해 본 결과, next 12에서 Module Federation과 함께 SSG로 빌드하면 SWC를 적용하더라도 빌드 속도와 메모리 사용량이 이상적으로 높다는 것을 발견했어요.\n마침 이전부터 next의 필요성에 대해서 팀원들과 논의를 했었는데요. 아래와 같이 의견이 모아져서 next의 장점보다 단점이 더 크다는 결론이 났고, next에서 webpack으로 마이그레이션을 시작했어요.\nTUBA는 내부 임직원 전용 서비스이기 때문에 SSR 등으로 첫 로딩 속도를 줄여도 이점이 크지 않다.\n대부분의 next 기능을 사용하고 있지 않고, SSG 빌드용 도구처럼 사용되고 있다.\nNext 제거하기\n하지만 막상 next를 제거하려고 보니 프로젝트 전반적으로 next를 사용하는 코드가 많았고, 무엇보다 공통 코드에서 사용되다 보니 점진적 마이그레이션을 하기 어려웠어요. 그래서 next-polyfill이라는 대체 구현 패키지를 만들어서 next에서 사용하고 있는 인터페이스를 최대한 비슷하게 구현했어요. Next 패키지를 사용하지 않아도 대체 구현 패키지를 통해서 필요한 기능을 코드에 쓸 수 있게 된거죠.\n// frontend-common/next-polyfill/head.tsx\nimport { ReactNode } from 'react';\nimport { Helmet } from 'react-helmet';\n\ninterface Props {\n  children: ReactNode;\n}\n\n/**\n * # react-router-dom의 <Helmet /> 을 사용해주세요.\n * @deprecated\n */\nexport default function Head({ children }: Props) {\n  return <Helmet>{children}</Helmet>;\n}\n\n위의 Head가 가장 간결하고 좋은 예시인데요.  App, useRouter 등 TUBA 프로젝트에서 사용하는 모든 컴포넌트 및 hooks를 비슷한 방식으로 구현했어요.\n이후 점진적으로 각 프로젝트의 package.json을 아래와 같이 수정하여 기존 next 패키지를 대체했어요. 그 결과 기존 코드를 크게 수정하지 않고도 빌드 시간이 약 86% 감소됐어요.\n- \"next\": \"^12.2.5\",\n+ \"next\": \"workspace:frontend-common/next-polyfill\",\n\n두 번째 시련: 지원이 종료된 패키지\n이번 시련은 현재 진행형인데요. Recoil이 사실상 지원이 종료된 것 같다는 소식이 들려왔어요. 뿐만 아니라 간간히 Recoil의 버그도 발생하고 있었고요. 특정 상황에서의 메모리 누수 문제 등 패키지의 불안정성이 계속 증가하는 것이 느껴졌어요.\n\n\n패키지 마이그레이션 의사결정\n그래서 Recoil을 대체할 수 있는 패키지를 찾기 시작했는데요. 아래 두 가지 조건을 필수로 생각했어요.\n활발하게 관리되는 패키지\nRecoil에서 넘어갔을 때 코드의 영향을 최소화할 수 있는 패키지\n위 조건에 부합하는 패키지가 Jotai라는 생각이 들었고, 팀원들도 동의하여 마이그레이션 방안을 모색하게 되었어요. 활발하고 관리가 되고 있으면서 Recoil에서 사용하던 상태관리 방식을 그대로 가져올 수도 있기 때문이죠.\n마이그레이션 스크립트 작성하기\nTUBA에서는 모든 상태 관리를 Recoil로 하고 있었기에 엄청나게 많이 사용하고 있었는데요. 아래 그림과 같이 909개의 파일에서 Recoil을 import하고 있었어요. 실제 코드에서의 사용까지 합치면 사용 범위가 더 넓었고요.\n\nRecoil의 구조상 React lifecycle 외부에서 데이터에 접근하기 어려워요. 그래서 Recoil과 Jotai와의 호환 레이어를 만들어 점진적 마이그레이션을 구상하기도 어려웠었는데요. 이 문제를 해결하고자 ts-morph 패키지를 활용했어요.\nts-morph는 TypeScript의 AST(추상 구문 트리)로 코드를 분석하고 조작하는 기능을 제공하는 라이브러리에요. AST는 소스 코드의 구조를 트리 형태로 표현한 것으로, 컴파일러나 인터프리터가 코드를 분석하고 실행하는 데 사용돼요. AST의 자세한 설명은 ESLint와 AST로 코드 퀄리티 높이기 아티클을 참고해보세요.\n먼저 ts-morph 패키지로 TypeScript 코드를 분석했어요. 그 다음, Jotai 함수와 1:1로 대응되는 Recoil 함수를 찾아서 모두 Jotai 함수로 변경했어요. 마지막으로 대응되지 않는 Recoil 함수는 직접 Jotai로 구현했어요. 이런 방식을 사용하면 개발자가 직접 코드를 수정하지 않고 기계적으로 코드 변경을 자동화할 수 있게 된답니다!\n예시를 하나 살펴볼게요. useRecoilValue()는 Recoil에서 상태 변경을 읽을 수 있는 함수인데요. Jotai에 있는 useAtomValue() 함수와 같은 역할을 합니다. ts-morph 패키지로 모든 파일에서 useRecoilValue()를 찾고 분석한 다음, useAtomValue() 함수로 변경했어요.\n\nimport { SyntaxKind } from 'ts-morph';\nimport { Context } from '../model/context';\n\nexport default function migrateUseRecoilValue({ sourceFile }: Context) {\n  // 1. 소스 파일에서 useRecoilValue 호출 부분만 찾아내기\n  const declarations = sourceFile\n    .getDescendants()\n    .filter(\n      node =>\n        node.isKind(SyntaxKind.CallExpression) &&\n        node.getFirstChildByKind(SyntaxKind.Identifier)?.getText() === 'useRecoilValue'\n    )\n    .map(node => node.asKind(SyntaxKind.CallExpression));\n\n\t// 2. 찾은 부분을 모두 useAtomValue로 변경하기\n  for (const declaration of declarations) {\n    declaration.getExpression().replaceWithText('useAtomValue');\n  }\n}\n\n위와 같은 마이그레이션 코드를 전체 코드 대상으로 실행했고, 마이그레이션 완료까지 54초 밖에 걸리지 않았어요. 또한 변경된 모든 파일을 대상으로 ESLint를 실행시켜 lint 에러도 없애고자 했는데요. 이것도 45초가 소요되었어요. 즉, 약 100초만에 900개의 파일을 마이그레이션 할 수 있었어요. 아래 검색 결과에 보이듯이 909개 파일에 잡히던 Recoil이 모두 제거됐어요(검색에 집힌 1개의 결과는 주석입니다).\n\n물론 모든 케이스를 완벽하게 대응할 수는 없었기 때문에 타입 에러 등이 발생했는데요. 발생한 에러를 하나씩 수정해줬습니다. 케이스들을 자세히 만들 수록, 발생하는 타입 에러가 줄어들어요. 계속 스크립트를 돌려보면서 빠진 것 같은 케이스들이 있다면 추가해주시면서 진행하는 것을 추천드려요.\n오늘은 토스 내부 임직원이 사용하는 TUBA 서비스에서 next와 Recoil 패키지를 마이그레이션한 경험을 알려드렸는데요. 프로젝트 전반적으로 사용되는 기술을 리팩토링을 고려하고 있거나, deprecated된 패키지 코드를 제거 및 마이그레이션하고 싶다면 제 글이 도움이 되셨길 바래요.\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "마이그레이션"
        }
      ]
    }
  },
  {
    "key": "framework-agnostic-library",
    "title": "여러 프레임워크에서 사용할 수 있는 라이브러리 만들기",
    "subtitle": "여러분은 라이브러리를 만들어봤거나, 만들어야겠다고 생각해본 적이 있나요? 이번에는 프론트엔드 개발 환경에서 높은 범용성을 나타내는 용어 중 하나인 “Framework Agnostic”에 대해 이야기 해보려고 합니다.",
    "publishedTime": "2024-06-03T14:41:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/framwork-thumb.jpg.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/framwork-thumb.jpg.jpg"
    },
    "editor": {
      "name": "임지훈",
      "shortDescription": "토스 Frontend UX Engineer"
    },
    "shortDescription": "여러분은 라이브러리를 만들어봤거나, 만들어야겠다고 생각해본 적이 있나요? 아마 개발자라면 한 번 쯤은 생각해보셨을 것 같습니다. 라이브러리를 만들 때는 해결하려는 문제와 설계 목적, 그리고 개발자의 요구에 따라 고려해야 하는 요소들이 다양합니다. 그중에서도 라이브러리가 다양한 환경에서 사용하려는 목표가 있다면, 범용성을 ",
    "fullDescription": "여러분은 라이브러리를 만들어봤거나, 만들어야겠다고 생각해본 적이 있나요? 아마 개발자라면 한 번 쯤은 생각해보셨을 것 같습니다. 라이브러리를 만들 때는 해결하려는 문제와 설계 목적, 그리고 개발자의 요구에 따라 고려해야 하는 요소들이 다양합니다. 그중에서도 라이브러리가 다양한 환경에서 사용하려는 목표가 있다면, 범용성을 고려하죠.\n이번에는 프론트엔드 개발 환경에서 높은 범용성을 나타내는 용어 중 하나인 “Framework Agnostic”에 대해 이야기 해보려고 합니다.\nFramework Agnostic\n소프트웨어 엔지니어링에서 \"Agnostic\"이라는 용어는 소프트웨어가 특정 환경(예: 운영 체제, 하드웨어 플랫폼, 프로그래밍 언어, 프로토콜 또는 기타 기술 영역)에 독립적으로 설계되었다는 속성을 나타냅니다. 따라서 Framework Agnostic은 프레임워크라는 환경에 독립적으로 설계되었다는 속성을 나타내죠.\nJavaScript 라이브러리 개발에서 Framework Agnostic 접근 방식은 특정 프레임워크에 종속되지 않는 라이브러리를 작성하는 것을 의미합니다. 이를 통해 라이브러리는 다양한 프레임워크와 호환 가능해지고, 개발자는 보다 넓은 범위의 프로젝트에서 라이브러리를 재사용할 수 있습니다.\n조금 더 범위를 축소해 프론트엔드 개발 관점에서 바라본다면, Framework Agnostic하다는 것은 React, Vue와 같은 웹 프레임워크 혹은 라이브러리에 상관 없이 의도된 동작이 잘 실행되도록 설계되었다는 것을 의미합니다.\n잘 알려진 Framework Agnostic 라이브러리,\nTanstack Query 들여다보기\nReact를 사용한다면 Tanstack Query라는 라이브러리를 한 번 쯤은 들어보셨을텐데요. JavaScript 애플리케이션에서 데이터를 가져오고 서버와의 데이터 통신, 캐싱, 동기화, 데이터 무효화 등을 간소화해주는 역할을 해요.\nTanstack Query도 Framework Agnostic한 라이브러리 중 하나예요. React Query라는 이름을 가졌던 라이브러리였지만 v4 버전부터 이름을 Tanstack Query로 바꾸고 Framework Agnostic한 라이브러리로 거듭났어요. Vue, Svelte, Solid 등 다양한 프론트엔드 라이브러리 및 프레임워크에서도 사용할 수 있게 되었죠.\nTanstack Query는 어떻게 Framework Agnostic한 라이브러리를 만들 수 있었을까요? 소스 코드를 간단하게 분석해봤어요.\nTanstack Query 레포지토리 구성\nTanstack Query 소스 코드를 보면 모노레포로 구성된 것을 볼 수 있어요. 모노레포에서 운영되는 패키지들이 모여있는 packages 디렉터리를 볼까요?\n\n이 디렉터리에 react-query, svelte-query 등 Framework에 의존성이 있어보이는 패키지들이 여러 개 존재하네요. 또, query-core라는 이름에서 알 수 있듯 핵심(core) 로직이 담겨있는 것처럼 보이는 패키지가 하나 있습니다.\nreact-query와 query-core의 관계성 알아보기\n우리의 추측대로라면 query-core는 프레임워크에 의존성이 없는 핵심 로직들만 들어있고, react-query는 리액트에 의존성이 있는 로직들이 들어있을 것 같아요. 우리의 추측이 맞는지 이 두 패키지의 package.json를 들여다볼게요.\n\nquery-core package.json를 보면 dependencies, devDependencies, peerDependencies가 없어요. 어떤 것에도 의존하지 않는 독립적인 로직이 담겨있음을 알 수 있어요.\n\nreact-query package.json을 보면 @tanstack/query-core라는 패키지가 의존성으로 설치되어 있어요. 이를 통해 react-query는 query-core라는 패키지에 의존하고 있고, 이 패키지가 제공하는 모듈을 이용한 코드가 존재한다는 것을 알 수 있어요.\n여기까지 확인한 점을 정리해볼게요.\nquery-core라는 패키지는 Tanstack Query의 핵심 로직을 담고 있어요.\nreact-query, vue-query와 같은 곳에서는 query-core를 이용해 React, Vue 등과 같은 프레임워크에 통합하는 패키지로 나누어져 운영되고 있어요.\nreact-query, vue-query 등은 query-core의 기능을 각 프레임워크(라이브러리)에서 사용할 수 있도록 어댑터 역할을 합니다. \nreact-query는 query-core에 의존성을 가지며, 이를 통해 핵심 로직을 재사용합니다.\nreact-query의 Hook(예: useQuery)은 내부적으로 query-core의 API (예: QueryClient)를 호출하여 데이터를 가져오고 상태를 관리합니다. react-query를 사용하는 사용자는 간접적으로 query-core의 API를 호출하는 것이죠.\n\nquery-core는 프레임워크에 종속되지 않은 상태로 모든 핵심 로직을 처리하고, react-query는 이 로직을 React의 라이프 사이클에 통합하여 React 컴포넌트에서 쉽게 사용할 수 있게 해줘요.\nFramework Agnostic한 코어, Framework에 통합하는 어댑터\nTanstack Query의 사례에서는 프레임워크와 관계 없이 동작하는 핵심 로직(query-core)와 특정 프레임워크에 통합하기 위한 로직(react-query, vue-query …)이 철저히 구분되어 있어요.\n이들을 각각 코어와 어댑터라고 부르는데요, 코어에는 프레임워크에 종속적이지 않은(Framework Agnostic) 핵심 로직들이 있고, 어댑터에는 React, Vue와 같은 프레임워크에서 사용할 수 있도록 코어의 인터페이스를 이용해 코어의 기능을 해당 프레임워크에서 이용할 수 있도록 통합해주는 로직들이 있어요.\n이렇게 코어와 어댑터를 분리하는 구조는 다양한 장점이 있어요. 새로운 프레임워크가 등장하거나 기존 프레임워크가 업데이트되더라도 코어를 변경하지 않고 어댑터의 수정만으로 대응할 수 있어요. 뿐만 아니라 코어와 어댑터 각각이 독립적으로 개발되고 유지보수되기 때문에 개발 효율성을 크게 향상시킬 수 있어요.\n반면에 단점도 존재하는데요. 특히 어댑터를 개발해 제공하는 것이 유지보수를 어렵게 만들 수도 있어요. 각 프레임워크마다 별도의 어댑터를 제공해야 하기 때문에, 프레임워크가 업데이트되거나 변경될 때마다 어댑터를 수정하고 테스트해야 하죠. 또, 코어의 인터페이스가 바뀐다면 이에 맞춰서 어댑터들도 변경이 일어나야 해요.\n이러한 과정에서 발생하는 시간과 자원의 소모는 무시할 수 없습니다. 만약 코어가 충분히 사용하기 편하고 간단하다면 어댑터를 제공하지 않는 것이 오히려 유리할 수 있습니다. 코어 자체만으로도 다양한 환경에서 쉽게 통합되어 사용할 수 있다면, 불필요한 어댑터 개발과 유지보수에 대한 부담을 줄일 수 있기 때문이죠.\n직접 설계해보기\n앞서 Tanstack Query의 사례를 통해 Framework Agnostic한 코어와 특정 프레임워크에 맞춘 어댑터를 분리하한 설계 방법을 알아봤는데요. 이제, 이 개념을 실제로 적용하는 과정을 살펴볼게요. 기존에 특정 프레임워크에 강하게 결합된 라이브러리를 재설계하여, 다양한 프레임워크에서 재사용할 수 있도록 만들어볼 거예요.\n이런 상황을 가정해볼게요. 한 회사에서 React를 사용하여 계산기 라이브러리를 개발했습니다. 이 라이브러리는 React와 강하게 결합되어 있어, React 환경에서만 사용할 수 있습니다. 즉, React의 컴포넌트와 상태 관리 시스템에 의존적이어서 다른 프레임워크에서는 사용할 수 없는 상태에요.\n회사의 성장과 함께 내부적으로 다양한 프레임워크를 사용하는 개발팀이 생기면서 Vue를 사용하는 팀이 새로 생기고, 계산기 라이브러리의 로직이 필요한 프로젝트가 있다고 합니다. 그러나 현재 계산기 라이브러리는 React에서만 동작하기 때문에 Vue 개발팀에서는 사용할 수 없어요.\n그래서 기존 계산기 라이브러리를 다양한 프레임워크에서 사용할 수 있도록 재설계하려고 합니다. 먼저 계산기 라이브러리의 코어 기능을 프레임워크에 독립적으로 분리하고, 이후 각 프레임워크에 통합하기 위한 어댑터를 만들거예요.\n\n계산기 라이브러리의 기존 형태\n기존의 React 계산기 라이브러리는 아래와 같은 그림으로 설계되어 있다고 가정합니다.\n\nuseCalculator라는 하나의 Hook에 위 그림과 같은 구조로 상태와 API가 구현되어 있어요.\n\n연산 함수들은 React의 useCallback으로 감싸져 있고, 상태들은 useState로 감싸져있어요. 오직 React 라이프사이클 안에서만 사용할 수 있다는 뜻이죠.\n이렇게 React에 강하게 결합된 useCalculator에서 핵심 로직인 부분과 React에 통합하기 위한 로직을 코어와 어댑터로 나눌게요. 모든 핵심 로직을 코어로 이동하고, 어댑터에서는 코어와 프레임워크를 연동하는 역할만 가지게 해볼게요.\n코어 인터페이스 만들기\n코어에는 계산기의 기본 연산 및 상태 관리 기능들을 정의할게요. 아래 그림은 코어가 제공해야하는 API와 내부적으로 관리해야 하는 상태, 그리고 각 API를 호출했을 때 어떤 상태 변화가 일어나야 하는지 보여주고 있어요.\n\n더하기, 곱하기, 빼기, 나누기의 연산이 일어나면 결과를 “연산 결과” 상태에 저장해요.\n연산 API를 호출하여 결과값이 업데이트될 때 이벤트를 발행하고, 그 이벤트를 구독할 수 있는 API도 제공해요.\n이벤트를 발행하고 구독할 수 있도록 인터페이스를 노출하는 것은 코어가 각 프레임워크의 상태와 상호작용하는 핵심 방식이에요. 이벤트 발생 및 구독 인터페이스로 코어는 프레임워크에 상태 변화를 알릴 수 있어요. 프레임워크가 해당 이벤트에 반응하여 코어의 상태와 프레임워크의 상태를 동기화할 수 있게 해줍니다.\n위에서 설명한 구조를 TypeScript로 의사 코드를 만들어보면 아래와 같아요.\ntype Unsubscriber = () => void;\n\nclass Calculator extends EventTarget {\n  private _result: number = 0;\n  \n  get result() {\n\t  return this._result;\n  }\n  \n  constructor() {\n\t  super();\n  }\n  \n  updateResult(newResult: number) {\n\t  this._result = newResult;\n\t  this.dispatchEvent('update', {\n\t\t  detail: this.result\n\t  });\n  }\n  \n  add(a: number, b: number) {\n\t  // ...\n\t  this.updateResult(...);\n  }\n  \n  subtract(a: number, b: number) {\n\t  // ...\n\t  this.updateResult(...);\n  }\n  \n  multiply(a: number, b: number) {\n\t  // ...\n\t  this.updateResult(...);\n  }\n  \n  divide(a: number, b: number) {\n\t  // ...\n\t  this.updateResult(...);\n  }\n}\n이 클래스에서 이벤트를 쉽게 핸들링하기 위해 자바스크립트 표준인 EventTarget을 extends합니다. \nEventTarget을 확장하면, 클래스 인스턴스가 DOM 객체처럼 addEventListener, removeEventListener, dispatchEvent 메서드를 사용할 수 있게 되어, 이벤트 리스너 등록, 제거, 이벤트 발행 기능을 가지게 돼요.\naddEventListener를 호출하면 내부적으로 이벤트 리스너를 등록하고, Calculator 인스턴스 내부에서 dispatchEvent를 호출하면 이벤트가 발행됨과 동시에 해당 이벤트를 구독하고 있는 이벤트 리스너들을 호출합니다.\n위 의사코드에서도 연산이 끝난 후 마지막에 updateResult() 를 호출하여 결과 값을 갱신하고 dispatchEvent를 호출해 이벤트를 발행하고 있어요.\n\nconst calculator = new Calculator();\n\n// 이벤트 리스너 등록\ncalculator.addEventListener('update', (event) => {\n  console.log('결과가 업데이트되었습니다:', event.detail);\n});\n\n// 연산 수행\ncalculator.add(5, 3);  // 결과가 업데이트되었습니다: 8\ncalculator.subtract(10, 4);  // 결과가 업데이트되었습니다: 6\ncalculator.multiply(7, 6);  // 결과가 업데이트되었습니다: 42\ncalculator.divide(20, 5);  // 결과가 업데이트되었습니다: 4\n위 예시와 같이 이벤트 리스너를 등록하면, 연산을 통해 결과가 업데이트될 때 등록한 리스너들이 호출돼요. EventTarget 스펙에 대한 자세한 설명은 MDN 문서를 참고하세요.\nReact 어댑터 인터페이스 만들기\nReact 어댑터는 코어와 React의 상태 및 라이프사이클을 연동합니다.\n\nReact 환경에서 코어를 사용할 수 있도록 하기 위해, React의 API로 코어의 API를 감싸 제공합니다.\n코어에서 발생하는 이벤트를 구독하여 React 상태를 업데이트하는 로직도 포함돼요. 이 동기화 로직은 React에서 제공하는 useEffect Hook을 이용합니다.\n이렇게 코어와 React 상태를 연동하여, 코어에서 발생하는 상태 변화를 실시간으로 반영합니다. 이는 사용자가 연산을 수행할 때마다 React에서 그리는 UI가 즉각적으로 업데이트되도록 해줍니다.\n위에서 이야기한 내용들을 정리하면, 아래 다이어그램과 같은 로직으로 작동하게 됩니다.\n\n\n최종 구조\n\n최종적으로 우리는 리액트에 강결합된 계산기 라이브러리를 Framework Agnostic한 코어와 React 어댑터로 분리했어요. 이제 Vue 어댑터를 만들면 Vue를 사용하는 팀에서도 이 라이브러리를 사용할 수 있게 되었어요.\n마치며\n오늘 Framework Agnostic이라는 개념에 대해 알아보았어요. Tanstack Query의 사례로부터 코어와 어댑터의 구분을 이해하고, 그 구분에 따라 라이브러리를 만드는 실습까지 했어요.\nFramework Agnostic은 어떤 특성을 나타내는 용어일 뿐이에요. 그렇기 때문에 Framework Agnostic한 라이브러리를 만드는 유일한 방법이라는 것은 존재하지 않아요. Framework Agnostic이라는 특성 또한 라이브러리의 설계 목적과 구조에 따라 여러 가지 형태로 나타날 수 있죠.\n범용적인 라이브러리를 만들고자 할 때, 반드시 Framework Agnostic한 특성이 고려되어야 하는 것은 아니에요. 범용성의 의미는 여러 가지로 해석될 수 있기 때문이에요. 예를 들어, React에 특화된 라이브러리일지라도, React에서 발생하는 다양한 문제 상황을 범용적으로 해결할 수 있는 기능을 제공한다면 그 자체로도 충분히 범용적이라 할 수 있습니다. 반면, 더 넓은 범위에서 여러 프레임워크에서 사용할 수 있는 라이브러리를 지향한다면 오늘 소개한 Framework Agnostic이라는 특성이 요구될 수도 있죠.\n중요한 것은 라이브러리가 목표로 하는 사용자의 요구를 충족시키고, 그들이 직면하는 문제를 효과적으로 해결할 수 있는지 여부입니다. 만약 여러분들이 라이브러리를 만들 때 프레임워크에 대한 범용성이 중요한 특성이 된다면,오늘 소개드린 내용이 도움이 될 수 있길 바랍니다.\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "27752",
    "title": "드래그 앤 드롭은 사실 편한 UX가 아니다?",
    "subtitle": "드래그 앤 드롭은 장애를 가진 사용자에게는 불편한 UX가 되기도 해요. 오늘은 “나눠모으기 통장” 서비스의 접근성 설계 단계부터 개발 과정까지 소개하고 접근성을 챙길 수 있는 간단한 방법을 알려드릴게요.",
    "publishedTime": "2024-05-30T16:22:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-tech-dragdrop.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-tech-dragdrop.png"
    },
    "editor": {
      "name": "황수재",
      "shortDescription": "토스뱅크 Frontend Developer"
    },
    "shortDescription": "스마트폰에서 드래그 앤 드롭(Drag & Drop) 많이 사용해 보셨을 텐데요. 리스트에 있는 요소의 순서를 변경할 때 드래그 앤 드롭은 많은 사용자에게 편하고 직관적인 UX로 보이죠. 하지만 장애를 가진 사용자에게는 불편한 UX가 되기도 해요.\n특히 터치스크린은 정밀한 조작이 필요하기 때문에, 운동장애가 있는 사용자들은",
    "fullDescription": "스마트폰에서 드래그 앤 드롭(Drag & Drop) 많이 사용해 보셨을 텐데요. 리스트에 있는 요소의 순서를 변경할 때 드래그 앤 드롭은 많은 사용자에게 편하고 직관적인 UX로 보이죠. 하지만 장애를 가진 사용자에게는 불편한 UX가 되기도 해요.\n특히 터치스크린은 정밀한 조작이 필요하기 때문에, 운동장애가 있는 사용자들은 정확한 위치로 요소를 끌어다 놓기 어려워요. 또한 시각 장애가 있는 사용자는 순서가 바뀌었다는 걸 시각적인 피드백만으로는 이해하기 어려울 수 있어요. \n토스뱅크에는 용도에 따라 계좌를 생성하여 돈을 나눠서 모을 수 있는 “나눠모으기 통장” 서비스가 있는데요. 서비스를 사용하는 모든 고객이 편하게 계좌의 순서를 바꿀 수 있도록 접근성을 굉장히 많이 신경썼어요. 오늘은 “나눠모으기 통장” 서비스의 접근성 설계 단계부터 개발 과정까지 소개드리고, 접근성을 쉽게 챙길 수 있는 방법을 알려드릴게요.\n\n디자이너, 컨설턴트, 개발자간 우당탕탕 커뮤니케이션\n토스뱅크에서는 순서 변경이라는 비교적 단순한 기능 하나에도 모든 고객에게 편리한 경험을 선사하고 싶었어요. 그래서 접근성이라는 목표를 향해 디자이너, 접근성 컨설턴트, 개발자 간의 긴밀한 협력이 시작됐어요.\n제한적인 화면 크기를 가진 스마트폰에서 깔끔한 UI를 제공하고 싶은 디자이너\n장애를 가진 사용자에게도 편리한 UX가 제공되길 원하는 접근성 컨설턴트\n이 모든 요구사항을 만족하면서 유지보수가 가능한 코드로 개발하고 싶은 개발자\nStep 1: 접근성 이슈의 이해와 설계\n이러한 이해관계자들이 모여서 드래그 앤 드롭 순서 변경의 접근성 이슈와, 개선 방식에 대해 심도 있는 논의를 시작했어요. 순서 변경이라는 기능이 간단해 보이지만 접근성 측면에서 고려해야 될 사항이 많았어요. \n스크린 리더에서도 드래그 앤 드롭 기능이 동작한다는 사실을 이때 알게 되었는데요. 시각장애인들은 사실상 이 동작을 사용이 어려울 수 있습니다. 그래서 디자이너는 드래그 앤 드롭 조작 방식과 시각장애인도 편하게 쓸 수 있는 탭으로만 조작 방식 두 가지 설계를 시작했습니다.\nStep 2: 요구사항 정리\n디자이너가 설계한 프로토타입을 기반으로 컨설턴트는 드래그 앤 드롭 순서 변경 설계에서 챙겨야 하는 아래 접근성 포인트들을 알려주셨어요.\n계좌 순서 이동 화면에서 각 계좌 버튼에 aria-pressed 속성을 적용하여 현재 드래그 중인지 아닌지를 true/false로 알림. 그러면 스크린 리더는 선택된 계좌의 토글 버튼을 “꺼짐” 또는 “켜짐”으로 읽어줌. title 속성으로 순서 이동 가능 힌트 추가.\ntrue 상태가 되면(하단에 내리기 올리기 버튼이 표시된 상태가 되면) 초점을 이동하기로 보내기. 이는 해당 버튼을 누른다는 것은 계좌 순서를 변경한다는 뜻이기 때문.\n위로 이동, 아래로 이동으로 버튼에 aria-label 속성 추가.\n위로 이동을 누르거나 아래로 이동을 누르면 “4번째로 이동했어요”, “2번째로 이동했어요” 등의 텍스트가 있는 요소에 aria-live polite 속성 추가함. 그러면 스크린 리더가 텍스트를 읽어줌.\n첫 계좌 또는 마지막 계좌면 위로 또는 아래로 이동 버튼을 disabled 처리. 접근성 초점은 다시 반대쪽 버튼으로 보내기. 그러지 않고 button disabled 속성을 사용하면 초점이 상단으로 튀는 현상이 안드로이드에서 발생할 수 있음.\n마지막으로 완료 버튼을 누르면 해당 계좌로 초점 되돌림.\nStep 3: 구현\n디자인, 접근성 컨설팅이 끝났으니 이제 제 구현만 남았는데요. 특히 까다로웠던 요구사항 하나만 소개드릴게요. 바로 사용자의 인터렉션 후 초점 이동이에요.\n순서를 바꿀 계좌 하나를 선택하면 바텀시트가 뜨면서 ‘올리기’ 또는 ‘내리기’ 버튼에 초점을 주어야 했어요. 아래 그림의 왼쪽 화면과 같이 바텀시트가 뜨는 타이밍에 맞추어 ‘올리기’ 또는 ‘내리기’ 버튼에 focus API를 통해 초점을 이동시켜주었습니다.\n순서 이동이 완료되면, 아래 그림의 오른쪽 화면과 같이 바텀시트가 사라지면서 순서 이동을 한 계좌에 다시 초점을 되돌려야 했는데요. 순서 이동을 선택한 계좌를 저장해두고, 바텀시트가 사라지는 타이밍에 다시 focus 를 잡아주었습니다.\n\n그리고 순서가 바뀌었을 때는 aria-live=”polite” 속성에 동적으로 변경된 순서를 스크린 리더에 읽어주도록 구현했습니다.\n<div ref={ariaLiveRef} aria-live=\"polite\" style={{ height: 0, overflow: 'hidden' }} />\n\n// 위에 생성해둔 dom을 조작하는 비지니스 로직\nconst ariaLiveRef = useRef<HTMLDivElement>(null);\n// NOTE: 스크린리더에게 메시지를 전달하기 위한 함수\nconst readA11yMessage = (message: string) => {\n  if (ariaLiveRef.current) {\n    ariaLiveRef.current.setAttribute('aria-hidden', 'false');\n    ariaLiveRef.current.innerText = message;\n    setTimeout(() => {\n      if (ariaLiveRef.current) {\n        ariaLiveRef.current.setAttribute('aria-hidden', 'true');\n      }\n    }, 500);\n  }\n};\n\n디바이스별로 다 다른 접근성\n다양한 웹 브라우저에서 일관된 동작과 UI를 제공하는 것을 크로스 브라우저 대응이라고 하는데요. 크로스 브라우저 대응 개발을 해보신 분들은 이게 얼마나 어렵고 시간이 많이 소요되는 일인지 아실 거예요. 접근성 또한 크로스 브라우저, os 버전 대응이 필요했어요. 서비스 사용자들에게 일관성 있는 접근성을 제공하기 위해 다양한 디바이스에서 검증하고 수정하는 작업도 같이 수행했습니다.\n예를 들어 아이폰에서 list의 role listitem에 title 속성을 넣어도 스크린 리더가 텍스트를 제대로 읽지 않는 문제가 있었어요. 또 aria-roledescription는 aria 버전 1.3부터 지원하는 걸 알게 됐는데요. 아이폰은 버전 1.3을 지원하지 않았습니다. 그래서 이런 문제들은 아래와 같이 대응했어요.\nrole=\"radio\"\ntitle=\"순서 이동 팝업 열기\"\naria-checked=true/false\n그리고 안드로이드에서는 onClick을 비동기로 사용하면 checkbox를 클릭할 때 상태를 두 번 읽어주는 현상을 발견했어요. 테스트하며 발견한 접근성 관련 버그는 최소 재현 가능 범위로 구현해서 구글에 이슈를 등록하기도 했습니다. \n// 접근성 대응하며 발견한 안드로이드 이슈\n// onClick이 async 하면 checkbox를 클릭할때 상태를 두번 읽어주는 현상\n<div\n  onClick={async () => {\n    await delay(1000);\n    setChecked(!checked);\n  }}\n  aria-checked={undefined}\n>\n  <input type=\"checkbox\" checked={checked} />\n</div>\n\n모두를 위한 간단한 접근성 챙겨보기 \n토스뱅크는 장애를 가진 고객에게 접근성을 제공하는 것을 매우 중요하게 생각하고 있어요. 하지만 “나눠모으기 통장” 서비스와 같이 꼼꼼하게 접근성을 챙기는 것은 어려운 일이죠. 그래서 자주 사용되고 비교적 간단한 접근성 개발 방법을 공유드릴게요.\n1. 언어(Language):  lang\n문서나 요소의 언어를 명시합니다. 가장 간단하게 챙길 수 있는 접근성 요소입니다.\n<html lang=\"ko\">\n2. 역할(Role): role\n요소의 역할을 명시합니다. 클릭이 가능한 영역은 가능하면 div가 아닌 button tag를 사용하시는 것을 추천하지만 상황이 여의치 않은 경우 role을 추가해주세요.\n<div role=\"button\">클릭 가능 영역</div>\n3. 대체 텍스트(Alternative Text): alt\n이미지에 대한 대체 설명을 제공하는 속성입니다.\n<img src=\"cat.jpg\" alt=\"귀여운 고양이 사진\">\n4. 폼 레이블(Label for Form Elements):  label 및 for\n웹 서비스는 다양한 폼을 사용하게 되는데 이때 폼 요소에 레이블을 제공합니다.\n<label for=\"product-name\">상품명:</label>\n<input type=\"text\" id=\"product-name\" name=\"product-name\">\n5. 폼 그룹(Form Grouping): fieldset 및 legend\n관련된 폼 요소들을 그룹화하고 설명을 제공합니다.\n<fieldset>\n  <legend>상품 정보</legend>\n  <label for=\"product-name\">상품명:</label>\n  <input type=\"text\" id=\"product-name\" name=\"product-name\">\n  <br>\n  <label for=\"product-description\">상품설명:</label>\n  <input type=\"text\" id=\"product-description\" name=\"product-description\">\n</fieldset>\n6. 탭 순서(Tab Order): tabindex\n요소의 탭 순서를 제어합니다. tabindex를 필요한 곳에 적절하게 적용하여 스크린 리더 사용자가 화면을 탐색하는 것에 도움을 줍니다.\ntabindex=\"0\": 자연스러운 탭 순서에 포함.\ntabindex=\"-1\": 포커스 가능하지만 탭 순서에는 포함되지 않음.\n<button tabindex=\"0\">버튼</button>\n<div tabindex=\"-1\">div</div>\n7. ARIA (Accessible Rich Internet Applications):그외 다양한 aria- 속성들\nARIA는 접근성을 향상시키기 위해 다양한 속성을 제공합니다.\naria-label: 요소에 레이블을 추가합니다. 특히 아래 예시 코드와 같이 “X”로 표시된 닫기 버튼에 활용하면 스크린리더 사용자에게 도움돼요.\n<button aria-label=\"닫기\">X</button>\naria-labelledby: 다른 요소의 ID를 참조하여 레이블을 제공합니다.\n<div id=\"title\">폼 제목</div>\n<form aria-labelledby=\"title\">\naria-describedby: 다른 요소의 ID를 참조하여 설명을 제공합니다.\n<input type=\"text\" aria-describedby=\"description\">\n<div id=\"description\">이름을 입력해주세요</div>\naria-hidden: 요소를 스크린 리더에서 숨깁니다.\n<div aria-hidden=\"true\">스크린 리더에서 보이지 않는 요소입니다</div>\n\n참고로, aria 속성들 중에서는 구형 브라우저에서 동작하지 않는 경우도 있어요. 예를 들어, aria-roledescription은 aria 1.3 스펙을 지원하는 최신 브라우저에서만 동작합니다.\n\n말씀드린 7 가지 속성 외에도 챙길 수 있는 부분이 많지만, 이것만이라도 적절하게 활용하면 웹 콘텐츠의 접근성을 크게 향상시킬 수 있습니다. 또한 토스와 같이 사내에서 디자인 시스템을 활용하고 있는 경우라면, 디자인 시스템에 이러한 속성들을 적용함으로써 전제 서비스의 접근성을 개선할 수 있어요. \n오늘은 토스뱅크에서 접근성을 다양한 방면에서 챙긴 사례를 알려드렸는데요. 지금 개발하고 있는 서비스에서도 적용할 수 있는 팁을 얻었길 바랍니다. 토스뱅크도 모든 고객이 편리하게 금융 서비스를 사용할 수 있도록 계속 노력하겠습니다.\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "접근성"
        }
      ]
    }
  },
  {
    "key": "27750",
    "title": "Transpiler, “사용”말고 “활용”하기",
    "subtitle": "매일 “사용”만 하는 transpiler, 토스뱅크에서는 한 단계 더 잘 “활용”해 보기로 했어요.  오늘은 transpiler로 로깅 과정을 개선한 사례를 소개 드릴게요.",
    "publishedTime": "2024-05-24T15:37:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/paymetns-benner-10.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/paymetns-benner-10.png"
    },
    "editor": {
      "name": "강현구",
      "shortDescription": "토스뱅크 Frontend Developer"
    },
    "shortDescription": "안녕하세요. 토스뱅크 프론트엔드 개발자 강현구입니다.\n프론트엔드 개발자라면 transpiler를 한 번쯤은 들어보거나 사용해 봤을 거예요. 프론트엔드 생태계가 빠르게 발전하면서, transpiler는 애플리케이션을 만들고 배포하는 과정에서 빠질 수 없는 필수 요소가 되었어요.\n토스뱅크에서는 개발 경험을 향상하기 위해서 t",
    "fullDescription": "안녕하세요. 토스뱅크 프론트엔드 개발자 강현구입니다.\n프론트엔드 개발자라면 transpiler를 한 번쯤은 들어보거나 사용해 봤을 거예요. 프론트엔드 생태계가 빠르게 발전하면서, transpiler는 애플리케이션을 만들고 배포하는 과정에서 빠질 수 없는 필수 요소가 되었어요.\n토스뱅크에서는 개발 경험을 향상하기 위해서 transpiler를 다양하게 활용하고 있는데요. 오늘은 transpiler로 로깅 과정을 개선한 사례를 소개 드릴게요.\nTranspiler란?\nTranspiler는 코드를 변환하는 도구를 의미해요. JavaScript의 ES6 문법을 ES5 문법으로 변환하거나, React의 JSX 및 Typescript 코드를 브라우저가 이해할 수 있는 Javascript로 변환하는 도구에요. Transpiler 덕에 여러 브라우저 호환성을 유지하면서 다양한 문법을 활용할 수 있죠.\n대표적인 transpiler로는 Babel과 SWC가 있어요. 토스뱅크는 마이크로 프론트엔드 구조로 여러 서비스들의 각자 입맛에 맞게 Babel과 SWC를 사용하고 있어요. \n언급한 내용만으로도 transpiler가 개발자에게 가져다준 편의성은 굉장해요. 비즈니스 로직에만 집중할 수 있도록 코드를 작성하는데 편리함을 제공하고, 부가적인 작업은 알아서 처리해 주는 거죠. 매일 이렇게 “사용”만 하는 transpiler, 토스뱅크에서는 한 단계 더 잘 “활용”해 보기로 했어요.\n로깅이란?\n토스뱅크는 데이터 기반으로 의사결정이 이루어져요. 올바른 결정을 위해서 개인정보 등 민감 정보를 제외한 유저의 클릭, 페이지뷰 등 다양한 유저 활동에 대한 데이터를 수집하고 있어요. 이 과정을 로깅이라고 해요. (유저의 데이터는 개인정보 처리 동의를 기반으로 수집하고 이용해요)\n로깅은 대부분의 서비스 코드에서 필요해요. 그래서 적절히 추상화하여 비즈니스 로직과 구분할 필요가 있어요. 전반적인 개발 경험을 해치지 않으면서 유저 데이터를 쌓기 위해서죠.\n또한 효율적으로 데이터를 수집하려면 화면에서 발생하는 모든 클릭 이벤트를 로깅하지 않고, 유의미한 정보만 로깅해야 해요. 예를 들어, 실제로 clickable한 버튼을 클릭했을 경우엔 로깅하고, clickable하지 않은 글자나 빈 화면을 클릭한 경우는 무시해야겠죠. \n여러분은 로깅을 어떻게 설계할 것 같나요? 크게는 아래 두 가지 방식이 있어요.\n수동으로 로깅 함수를 실행하는 방식\n<Button\n  onClick={() => {\n    log({ content: '다음' });\n    handleClick();\n  }}\n>\n  다음\n</Button>\n추상화된 로깅 컴포넌트를 활용하는 방식\n<LoggingClick>\n  <Button onClick={handleClick}>\n    다음\n  </Button>\n</LoggingClick>\n\n이외에도 여러 다양하고 창의적인 방식들이 많을 것 같아요. 하지만 아무것도 하지 않아도 로깅이 알아서 되면 어떨까요? 토스뱅크에서는 원래 로깅을 어떻게 하고 있었고, transpiler로 로깅을 자동화한 방법을 알려드릴게요.\n2% 부족한 클릭 로깅\n기존에 토스뱅크 프론트엔드 챕터가 선택한 클릭 로깅 방식은 다음과 같아요. 이벤트 캡처링(window listen)과 data attribute 두 가지를 활용해서 로깅을 처리했어요. \n<Button onClick={() => {}} data-click-log>\n  다음\n</Button>\n유저가 버튼을 클릭했을 때, click event를 캡처링을 통해 인지하고, 클릭 타깃에서 가장 가까운 data-click-log 속성을 지닌 DOM을 찾아요. 찾은 DOM의 text node를 파악하여 유저가 클릭한 컴포넌트의 정보를 아래와 같이 로깅해요.\n{\n  log_type: 'click',\n  content: '다음',\n}\n하지만 매번 data-click-log를 붙이는 일이 번거로웠어요. 타이핑에 실수가 생기면 로그가 누락될 수 있는 위험도 존재했어요. Props가 많아진다면 문제를 찾기 더 어려웠죠.\n<Button\n  type=\"primary\"\n  variant=\"weak\"\n  size=\"large\"\n  data-cilck-log // 오타\n  onClick={() => {}}\n  disabled={false}\n  loading={false}\n  css={{ minWidth: 100, minHeight: 80 }}\n>\n  다음\n</Button>\n단순 실수를 줄이기 위해 별도의 lint rule을 추가하거나, 자동완성 기능을 제공하는 방향도 고려했지만, 문제가 발생하는 근본적인 원인을 해결하기로 했어요.\n부족한 2% 채우기\n토스뱅크의 기존 로깅 방식을 다시 정리해 볼게요. \n클릭 이벤트가 발생하면, data-click-log 속성을 지닌 DOM을 찾아 로깅한다\n이벤트 발생 시 로깅해주는 시스템은 이미 충분히 자동화가 되어있었어요. 그래서 clickable한 요소에 data-click-log 속성을 자동으로 주입해 줄 수만 있다면, 문제를 근본적으로 해결하여 부족한 2%를 채울 수 있다고 판단했어요. \n아래 1번 코드가 2번 코드로 변환되면 문제를 해결할 수 있었죠. \n1. \n<Button onClick={() => {}}>\n  다음\n</Button>\n\n2.\n<Button onClick={() => {}} data-click-log>\n  다음\n</Button>\n“특정한 조건에 따라, 알맞게 코드를 변환하는 것” transpiler가 적합한 도구라고 판단했어요. Clickable한 요소라는 조건에 따라, data-click-log 속성이 들어가도록 코드를 변환하는 거죠.\nTranspiler로 로깅 플러그인 만들기\nClickable 하다는 것은 onClick, onChange, onTouchStart와 같은 유저의 클릭에 반응하는 이벤트 핸들러가 존재하는 것이라고 규정한다면, clickable 조건에 대한 판단도 충분히 할 수 있었어요. \n이런 특징을 활용해서 SWC와 Babel용 플러그인을 만들었어요. \nBabel용 플러그인을 예시로 소개해볼게요. \nconst CLICK_EVENTS = ['onClick', 'onTouchStart', 'onChange', 'onMouseDown'];\nconst CLICK_LOG_ATTR = 'data-click-log';\n\nfunction plugin({ types: t }: typeof babel): PluginObj {\n  return {\n    name: 'babel-plugin-tossbank-logger',\n    visitor: {\n      JSXOpeningElement(path) {\n        const { node } = path;\n\n        const hasOnClickAttribute = node.attributes.some(attr => {\n          return CLICK_EVENTS.includes(attr.name.name);\n        });\n\n        if (hasOnClickAttribute) {\n          const dataClickLogAttribute = t.jSXAttribute(t.jSXIdentifier(CLICK_LOG_ATTR), null);\n\n          node.attributes.push(dataClickLogAttribute);\n        }\n      },\n    },\n  };\n}\n\nBabel은 AST(추상구문트리)를 만들고, 이를 플러그인에게 제공하여 각 노드들을 순회하며 처리할 수 있도록 인터페이스를 제공하고 있어요. Visitor의 JSXOpeningElement는 JSX 태그의 시작 요소들을 순회하며 실행할 콜백을 정의한 거예요. \n위 코드를 살펴보면 각 요소들을 순회하며 해당 노드가 onClick ,onTouchStart, onChange, onMouseDown처럼 clickable 한 이벤트 핸들러가 존재하는지(hasOnClickAttribute) 체크해요. clickable 한 이벤트가 존재한다면 data-click-log 라는 data attribute를 주입하고 있어요. \nSWC용 플러그인도 마찬가지로 동일한 로직에 Rust 기반으로 만들어 제공했어요. \n이 로깅 플러그인을 활용하는 개발자는 아래 코드와 같이 클릭 로깅을 생략하고 비지니스 로직만 작성할 수 있게 된거예요.\n<Button onClick={() => {}}>\n  다음\n</Button>\n이 외에도, 클릭한 요소가 어떤 디자인 시스템 컴포넌트인지 자동으로 로깅 처리를 할 수도 있고, 특정 조건에서는 클릭 로깅을 방지하는 등 원한다면 활용할 수 있는 범위는 더 넓어요. \n이제 누가 개발을 하던 항상 동일하게 로깅을 처리하고, 동일한 로깅 결과가 나오도록 보장할 수 있게 되었어요. \n새로운 시선으로 바라보기\n로깅 외에도 토스뱅크에서는 다국어 처리에 transpiler를 활용하고 있어요. Transpiler는 아직 생각하지 못한 더 다양한 영역에서 우리의 개발 경험을 개선해 줄 거라고 생각해요. \n여러분도 이런 코드가 있다면 transplier를 활용할 수 있을지 고민해 보면 어떨까요? \n반복적, 규칙적으로 코드 변경(작성/수정/삭제)이 필요하고\n누락과 오타 등 휴먼 에러가 빈번하게 발생하며\n비즈니스 로직을 침범하는 코드들\nTranspiler를 예시로 이야기했지만, 다른 도구들도 마찬가지로 “어디에 쓰이는지”보단 “무엇을 하는지”를 알면, 마주한 문제들을 예상보다 쉽고 창의적이게 해결할 수 있어요. 토스뱅크 프론트엔드 챕터는 앞으로도 사용하는 도구들을 다양한 방면으로 활용해서, 마주한 문제들을 쉽게 해결할 수 있도록 고민해 나아갈 거예요.\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "Frontend"
        },
        {
          "content": "자동화"
        }
      ]
    }
  },
  {
    "key": "lightning-talks-package-manager",
    "title": "패키지 매니저의 과거, 토스의 선택, 그리고 미래",
    "subtitle": "토스는 왜 패키지 매니저로 Yarn을 선택했을까요? 이번 라이트닝 토크에서는 JavaScript의 패키지 매니저, 동작 방식, 그리고 토스의 선택과 앞으로의 방향성에 대해 이야기해 보려고 해요.",
    "publishedTime": "2024-05-23T15:33:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/tech-banner-11.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/tech-banner-11.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "토스 기술 조직의 각 챕터는 라이트닝 토크에서 다양한 주제에 대한 인사이트와 아이디어를 자유롭게 공유합니다. 기록을 통해 생생한 라이트닝 토크 현장을 함께 느껴보세요!\n이번 라이트닝 토크에서 다루는 내용\n- 패키지 매니저란?\n- 패키지 매니저가 동작하는 세 가지 단계\n- npm, pnpm, Yarn PnP에서 패키지를 설",
    "fullDescription": "토스 기술 조직의 각 챕터는 라이트닝 토크에서 다양한 주제에 대한 인사이트와 아이디어를 자유롭게 공유합니다. 기록을 통해 생생한 라이트닝 토크 현장을 함께 느껴보세요!\n이번 라이트닝 토크에서 다루는 내용\n- 패키지 매니저란?\n- 패키지 매니저가 동작하는 세 가지 단계\n- npm, pnpm, Yarn PnP에서 패키지를 설치하는 방법의 차이\n- 토스가 Yarn을 선택한 이유와 앞으로의 방향성\n- 번외: 브라우저에서 웹 표준으로 패키지를 관리하는 방법\n오늘 다룰 내용은, 많아요. 사실 이렇게 많을 줄 몰랐어요! 주제는 패키지 매니저 인데요. 어떤 기술을 왜 선택했는지 그 배경을 이해하려면 먼저 개념을 명확히 알아야 해요. 그래서 JavaScript 패키지 매니저가 무엇인지 먼저 다룬 뒤에, 패키지 매니저가 동작하는 세 가지 단계를 설명할게요. 그리고 npm, pnpm, 그리고 Yarn, 이 세 가지 패키지 매니저가 어떻게 다른지 서로 다른 패키지 매니저의 특징을 살펴보고, 마지막으로 토스는 왜 Yarn을 선택했고, 앞으로는 어떤 방향성이 될 것인지 소개하겠습니다.\n패키지 매니저란?\n패키지 매니저의 정의부터 시작해보죠. 잘 아시는 분들도 많을 텐데요. JavaScript나 TypeScript를 사용하면 이렇게 require나 import 구문을 사용해서 외부 의존성을 참조하잖아요. 그걸 올바르게 참조할 수 있도록 보장해주는 프로그램이라고 생각하시면 돼요.\nimport React from '/Users/raon0211/path/to/react/index.js';\nimport { sum } from '/Users/raon0211/path/to/@toss/utils/index.js'\nJavaScript 표준인 ECMAScript에 따르면, 원래는 정확한 절대 경로나 상대 경로를 통해서만 import 할 수 있어요. 실제로 Deno나 브라우저의 JavaScript 표준 문법을 보면 다 정확한 절대 경로를 사용하고 있죠. 하지만 실제로 이렇게 쓰지 않잖아요. 우리는 보통 이렇게 쓰고 싶어 하죠.\nimport React from 'react';\nimport { sum } from '@toss/utils';\n\nsum(1, 2, 3);\nconst _ = require('lodash');\n하지만 이렇게 하면 문제가 생깁니다. 예를 들어, react가 정확히 어떤 버전인지, @toss/utils이 어떤 버전인지 모호하다는 문제인데요. 예를 들면 React는 18.0.1일 수도, 18.3.1일 수도 있고, 최근에 나온 19 베타일 수도 있잖아요. @toss/utils도 버전이 많고, lodash 라이브러리도 마찬가지죠. 그러면 정확한 정보는 어디서 제공할까요? 우리는 소스 코드보다 상위 디렉토리인 package.json 파일에 명시해요.\n{\n  \"dependencies\": {\n    \"react\": \"^18.2.0\" // react는 ≥ 18.2.0, <19 사이의 어떤 버전이든지 쓸 수 있다고 명시\n  }\n}\n이렇게 명시된 의존성 정보를 바탕으로, 모든 소스 코드 파일이 특정 버전의 라이브러리를 사용할 수 있도록 보장합니다. 일반적으로 package.json 파일에 디펜던시를 명시하고, npm install 혹은 yarn install을 하면, 해당 의존성의 명시된 버전을 설치하게 됩니다. 즉, 패키지 매니저가 앞서 이야기 한 모호한 버저닝 문제를 해결해주는 거예요.\n패키지 매니저가 동작하는 세 단계\n패키지 매니저의 정의를 이야기 해봤어요. 이렇게 보면 패키지 매니저가 생각보다 간단하게 느껴지는데요. 버저닝 문제를 해결하기 위해 실제 동작하는 방식을 살펴보면 꽤 복잡해요. \n다음은 패키지 매니저 중 하나인 Yarn을 터미널에 실행했을 때 볼 수 있는 화면인데요.\n\nYarn을 포함한 패키지 매니저는 이렇게 ‘Resolution’, ‘Fetch’, ‘Link’ 세 단계로 동작해요. 각 단계를 알아볼게요.\nResolution 단계\nResolution 단계 세 줄 요약\n- 라이브러리 버전 고정\n- 라이브러리의 다른 의존성 확인\n- 라이브러리의 다른 의존성 버전 고정\n첫 번째는 Resolution 단계예요. 영어 뜻을 생각해보면 ‘문제를 해결하다’라고 이해할 수 있죠. 어떤 문제를 해결하는 지가 중요할 텐데요. 첫 번째 문제는 라이브러리를 정확한 버전으로 고정하는 문제예요. 패키지 매니저는 Resolution 단계에서 package.json 파일에 명시된 버전 범위에 따라 정확한 버전을 결정합니다. 예를 들어, “react: ^18.2.0” 이라고 명시되어 있으면, ^이 나타내는 규칙에 따라 ≥ 18.2.0, <19 사이의 어떤 버전이든 사용할 수 있어요. 패키지 매니저는 저 범위를 만족하는 선에서 가능한 최신 버전을 사용하려고 해요. 즉, 최신 버전인 18.3.1을 선택할 수 있습니다.\n다음 문제는 설치한 라이브러리가 사용하는 다른 라이브러리, 즉 의존성의 의존성 문제인데요. JavaScript에서는 패키지끼리 의존성을 갖는 상황이 흔하잖아요. 예를 들어서, @toss/use-overlay 는 react 를 사용해요. 그런데 react도 의존성을 가지고 있죠. 그래서 의존성이 또 어떤 의존성을 가지는지 확인하는 작업이 필요해요.\n마지막으로 그 의존성의 버전도 고정해야 한다는 건데요. JavaScript에서는 위와 같이 의존성의 버전을 범위로 명시하고, 패키지 간에도 의존성을 가지기 때문에, 똑같은 package.json에 대해서도 사용하는 의존성 버전이 완전히 달라질 수 있어요.\n예를 들어서, 어떤 기기에서는 Next.js 13.1 버전과 React 18.1.0 버전을 사용하고, 다른 기기에서는 Next.js 13.2, React 18.2.0 을 사용할 수 있는 거죠. 저희 입장에서 제일 좋은 건 당연히 버전마다 동작이 똑같은 건데요. 슬프게도 당연히 동작이 다를 수 밖에 없고, 버그가 생길 수도 있어요. ‘제 PC에서는 잘 돼요’라고 하는 상황이 이럴 때 생기죠. 이런 의존성 고정 문제를 전부 해결하는 게 Resolution 단계입니다.\n다시 정리하자면, Resolution 단계는 모든 기기에서 고정된 버전을 사용할 수 있도록 합니다. 의존성 버전을 전부 고정시키고, 의존성의 의존성을 다 찾아서 그 버전도 고정시키며, 결과물을 yarn.lock이나 package-lock.json에 저장해요.\nFetch 단계\nFetch 단계 한 줄 요약\n- 결정된 버전의 파일을 다운로드 하는 과정\n두 번째는 Fetch 단계인데요. 이건 조금 쉬워요. Resolution의 결과로 결정된 버전을 실제로 다운로드하는 과정이에요 yarn.lock에 명시된 패키지가 있잖아요. 패키지 매니저는 이 과정에서 네트워크를 통해 필요한 파일들을 가져오는데, 그 과정이 Fetch 단계입니다. 일반적으로, 99%는 npm 레지스트리에서 다 받아옵니다.\nLink 단계\nLink 단계 한 줄 요약\n- Resolution/Fetch 된 라이브러리를 소스 코드에서 사용할 수 있는 환경을 제공하는 과정\n세 번째는 가장 까다로운 Link 단계인데요. npm, pnpm, PnP(Plug'n'Play) 사례를 각각 살펴보려고 해요. \n[1] npm Linker\n첫 번째로 가장 익숙한 node_modules 기반의 Linker를 살펴볼게요. package.json에서 명시하는 모든 의존성을 그냥 node_modules 디렉토리 밑에다가 하나하나씩 쓰는 게 npm Linker의 역할인데요.\n예를 들어 소스 코드에서 React와 TDS 모바일 라이브러리를 사용한다면, my-service의 node_modules하위에 React랑 TDS 모바일 패키지를 추가해요. TDS 모바일 패키지에도 node_modules가 있다면 @radix-ui/dialog를 또 그 밑에 깔아주는 게 npm Linker가 하는 일이죠.\nmy-service/\n└─ node_modules/\n|  ├─ react/\n|  |  \n|  └─ @tossteam/tds-mobile/\n|     └─ node_modules/\n|         └─ @radix-ui/react-dialog\n|\n└─ src\n    └─ index.ts\n사용해 보신 분들은 잘 아실텐데, 이 방식에는 단점이 꽤 많아요. 일단 패키지를 찾으려고 하면 node_modules를 계속 타고 올라가면서 파일을 여러 번 읽어야 해요. 그래서 import나 require 하는 속도가 느려지죠. 또, 디렉토리 크기가 너무 커져요. 실제로 파일 시스템에 디렉토리와 파일을 하나하나 만들고 쓰기 때문이에요. \n예를 들어 만약 100개 프로젝트에서 React 18.2.0 버전을 쓴다고 하면 정말로 100번씩 React 18.2.0이 추가되는 거예요. 그래서 ‘호이스팅(Hoisting)’이라는 특이한 방법을 사용하기도 하는데, 최적화가 완전히 되는 것도 아니고 불안정하기도 해서 좋은 방법은 아니에요.\n[2] pnpm Linker\n이런 단점 때문에 pnpm이 만들어졌어요. pnpm문서에 보면 ‘fast, disk space efficient’한 패키지 매니저라고 써있어요. 즉, 퍼포먼스가 향상된(performant) npm 이라고 이해하시면 돼요.\n\nnpm에서 문제였던 node_modules를 하나씩 쓰는 것 때문에 느리고 용량도 많이 차지하는 걸 개선했다는 건데요. 중요한 건 ‘어떻게’ 개선했냐는 거겠죠.\npnpm Linker는 기존의 node_modules 디렉토리를 그대로 사용해요. 대신 보다 빠르고 용량을 최적화하는 방식을 사용해요. Hard link 방식 덕분인데요. 보통 OS나 시스템 프로그래밍에서 파일 시스템을 관리할 때 쓰는 개념으로 알고 계실 거예요. Hard link는 쉽게 말해 alias를 거는 거예요. npm처럼 단순 복붙하는 게 아니라 alias가 생기면 거기로 바로 접근하는 거에요. 그래서 의존성이 디스크에 하나만 설치가 돼요. node_modules를 쓸 때도 파일을 하나하나 쓸 필요가 없어지고, 속도도 훨씬 빠르죠. 이게 pnpm이 접근하는 방식입니다. \nnode_modules 디렉토리 크기도 무척 작아요. 그치만 조금 뒤 소개해드릴 PnP 방식 보다는 느릴 수 밖에 없어요. 왜냐면 node_modules 디렉토리를 계속 돌면서 alias를 하나씩 걸거든요. 그래서 약간 느리지만, npm처럼 파일 하나씩 쓰는 건 아니기 때문에 훨씬 빠르긴 해요. 게다가 호환성도 좋죠. 그래서 우리가 npm 쓰다가 pnpm으로 바꾸면 갑자기 ‘오, 빨라지네. 그리고 잘 되네, 뭐야 좋네!’ 이렇게 생각하게 되는 거죠.\n다만 node_modules 디렉토리는 그대로 유지하기 때문에, require, import 시 파일 읽기가 많이 발생해서 중간중간 멈추기도 해요.\n[3] PnP Linker\n이 node_modules 디렉토리에서 벗어나고 싶다는 생각으로 래디컬하게 접근한 게 PnP인데요. 결국 node_modules 없이 의존성을 처리하는 방법을 찾아냈어요.\nPnP는 ‘패키지를 import 할 때 중요한 것은 단 두 가지’라는 관점에서 접근해요. 먼저, ‘어떤 파일’에서 import 하는가, 그리고 ‘무엇’을 import 하는가예요. 즉, 앞의 npm과 pnpm처럼 node_modules를 순회하는 게 중요하지 않다고 생각한 거죠. 그래서, node_modules 디렉토리가 아니라 JavaScript 객체로 똑똑하게 처리해요.\nPnP 동작을 좀 더 자세히 살펴볼게요. yarn install을 하면, 다음과 같은 .pnp.cjs라는 파일이 생겨요. 아래 예시 파일을 해석해보면, my-service라는 디렉토리에서 React를 import 할 수 있고, 18.2.0 버전을 사용하면 된다는 뜻이에요.\n[\"my-service\", /* ... */ [{\n  // ./my-service에서...\n  \"packageLocation\": \"./my-service/\",\n  \"packageDependencies\": [\n    // React를 import 하면 18.2.0 버전을 제공하라.\n    [\"react\", \"npm:18.2.0\"]\n  ]\n]\n다음 예시도 마찬가진데요. React를 사용할 때도 npm 18.2.0이 있는 위치를 알려주고, 그 아래에 있는 패키지를 import 하면 명시된 버전의 패키지를 반환하면 된다는 뜻이에요.\n/* react 패키지 중에서 */\n[\"react\", [\n  /* npm:18.2.0 버전은 */\n  [\"npm:18.2.0\", {\n    /* 이 위치에 있고 */\n    \"packageLocation\": \"./.yarn/cache/react-npm-18.2.0-98658812fc-a76d86ec97.zip/node_modules/react/\",\n    /* 이 의존성들을 참조한다. */\n    \"packageDependencies\": [\n      [\"loose-envify\", \"npm:1.4.0\"]\n    ],\n  }]\n]],\n이렇게 PnP는 의존성을 찾는 방법을 JavaScript Map으로 관리해요. 그러면 Yarn을 실행하는 순간에 어떤 일이 벌어질까요? Node.js 프로세스가 이 PnP Map을 메모리에 전부 로드하고 import와 require 문에서 이 Map을 참조합니다. Node.js의 --require 옵션과 --loader 옵션을 사용해서 Map을 로딩시키는데요. import와 require의 동작을 바꾸는 Node.js의 API를 사용해서 동작을 바꿔서 참고해 사용하도록 한 거죠.\n이렇게 하면 일단 설치 속도가 빨라요. 왜냐면 yarn.lock 기반으로 .pnp.cjs 파일만 만들어서 쓰면 끝나거든요. 파일 하나만 쓰면 되니 설치 속도가 빨라지는 거죠. 그리고 import나 require 하는 속도도 빨라요. 메모리에 파일이 로드되고 나면, 그냥 Map 연산만 하기 때문이에요. node_modules 디렉토리를 순회할 필요가 없죠. 이런 측면에서 PnP는 굉장히 속도에 집중한 접근이라고 할 수 있어요. 물론 단점도 있어요. 일단 Node.js 프로세스가 뜨는 속도가 느리고, node_modules 디렉토리와 호환성이 낮아요.\nLink 파트를 요약해 보면, Link는 Resolution/Fetch한 것을 기반으로 실제로 소스 코드에서 필요한 라이브러리를 사용할 수 있게 환경을 제공해 주는 단계에요. 우리가 실제로 import나 require 구문을 사용하는 환경 말이죠. npm은 node_modules 디렉토리에 파일을 하나하나 쓰는 방식으로, pnpm은 Hard link를 사용해서 alias를 거는 방식으로 속도를 좀 더 빠르게 한 거고요. Yarn은 여전히 부족하다며 더 래디컬하게 node_modules 없는 방식을 도입했습니다.\nPnP vs. Zero-install\n다음으로 PnP랑 Zero-install 관련해서 짚고 넘어가고 싶은 내용이 있는데요. 이 두 가지를 헷갈리시는 분들이 많아서 비교해 보는 시간을 마련했어요. 한 마디로 정리하면, PnP와 Zero-install은 다릅니다.\n먼저 PnP는 node_modules 없이 JavaScript Map 객체를 활용해 의존성을 엄격하고 빠르게 관리하는 접근 방식입니다. 그리고 Zero-install은 PnP의 JavaScript Map 객체와 Fetch된 의존성들까지 모두 Git에 넣어 버전을 관리하자는 방식입니다. 쉽게 말해, npm을 사용하면서 node_modules 디렉토리를 버전 관리하는 것이 Zero-install이죠.\n\nnpm을 사용하면서 Zero-install을 할 수도 있고, PnP를 사용하면서 Zero-install을 할 수도 있습니다. 하지만 npm 방식으로 설치하면 중복된 의존성들이 너무 많아져서 용량이 커져요. 반면, PnP는 효율적으로 하나의 의존성만 설치되므로 버전 관리가 용이해요. 그래서 Zero-install을 도입하게 된 것입니다. 특히 엔터프라이즈 레벨에서는 편리한 점이 많습니다.\n과거 토스 프론트엔드 팀이 작을 때, 브랜치를 바꿀 때마다 yarn install을 돌리고, 잘 안 될 때는 node_modules를 지우고 다시 깔아야 했는데요. 이런 문제를 해결할 때 Zero-install이 유용했습니다. 모든 의존성을 버전 관리하면 이런 문제가 해소돼요. 그러나 이 방식에도 단점이 있습니다. 레포지토리 사이즈가 커지고, Git 관리가 어려워 진다는 점인데요. 지금은 효용 대비 부담이 커져서 Zero-install 을 기본으로 끄는 방향으로 가고 있습니다.\n토스가 Yarn을 선택한 이유와 앞으로의 방향성\n이제 드디어 토스가 패키지 매니저를 관리하는 방향성에 대해 이야기 해 볼게요. 토스는 지금까지 Yarn을 사용하고 있어요. 크게 보면 네 가지 이유가 있는데요. \n첫 번째는 Yarn의 아키텍처가 매우 잘 설계되어 있기 때문이에요. 패키지 매니저의 각 구성 요소가 모듈화되어 있고, 인터페이스가 잘 분리되어 있습니다. 예를 들어 Resolution 단계의 코드와 Fetch 단계, Link 단계의 코드가 섞여있지 않고 모듈화 되어 있는 건 PnP 밖에 없어요. 코드 작성 방식과 컨벤션도 일관적이죠.\n두 번째 이유는 정확성 때문이에요. PnP는 가장 엄격하고 정확한 설치 방식이기 때문에 에러 발생 가능성이 적습니다. dependencies/peerDependencies에 명시하지 않은 의존성은 사용할 수 없기도 하고요. 덕분에 PnP에서 잘 작동한다는 것은 곧 npm, pnpm에서도 잘 작동한다는 것을 뜻하죠.\n세 번째 이유는 성능입니다. PnP는 파일 I/O의 수가 적고, 설치 과정이 간단해서 속도가 빠릅니다. 실제로 벤치마크 결과를 보면, npm은 30초가 넘게 걸리지만, pnpm은 8초 정도 걸리고, Yarn은 그보다 더 빠릅니다. CLI 품질도 제일 좋고, 읽기 편해요.\n\n마지막 이유는 확장 가능성입니다. Yarn은 코어 부분을 제외하면 전부 플러그인화가 되어 있어서(Pluggable), 다양한 기능을 쉽게 추가할 수 있습니다. 저희도 자체적으로 여러 플러그인을 만들어서 사용하고 있죠. pnpm도 좋은 패키지 매니저이지만, Yarn의 플러그인 API가 더 확장성이 높다고 생각합니다.\n그래서 토스는 현재 Yarn을 계속 사용하고 있습니다. 다만, Zero-install을 끄고, 레포지토리 사이즈를 줄이는 방향으로 가고 있습니다. 브랜치를 변경할 때 yarn install을 매번 하는 불편함은 있을 것으로 예상해요. 하지만 레포지토리 사이즈가 줄어들고, Git 속도 증가할 것으로 예상되고요. .pnp.cjs 파일의 충돌도 더 줄어들 거예요. \n번외: JavaScript 표준으로 패키지를 관리하는 방법\n관련해서 간단하게 재미있는 점을 하나 소개해드리려고 합니다. package.json이 없는 브라우저나 Deno와 같은 환경에서는 어떻게 패키지 매니저를 관리할까요? 놀랍게도 브라우저에서도 패키지 매니저와 비슷한 방식이 있고, Deno 같은 경우에는 이미 이런 방식을 사용하고 있어요. 이 방식은 JavaScript 표준이라고도 할 수 있는데, ‘Import Map’이라고 부릅니다.\n예를 들어, Import Map에서는 React를 다음과 같이 명시해요:\n\n<script type=\"importmap\">\n{\n  \"imports\": {\n    \"react\": \"https://cdn.jsdelivr.net/npm/react@17/umd/react.development.js\"\n  }\n}\n</script>\n이후, 스크립트 타입을 모듈로 지정하고, 다음과 같이 React를 가져오면 됩니다:\n<script type=\"module\">\n  import React from 'react';\n</script>\n이 방식에서는 Import Map이 'react'를 지정된 URL로 매핑하여, 해당 URL에서 React를 불러와요.\n놀랍게도, Deno와 브라우저는 이미 이 방식을 채택하고 있습니다. 제가 알기로는 JavaScript 표준의 방향성이 이렇고, Node.js도 Import Map을 지원하고 있어요. 그래서 먼 미래에는 패키지 매니저와 관련한 갑론을박이 별로 중요하지 않을 수도 있다고 예상해 봅니다. 패키지 매니저 없이 모든 의존성을 가져오는 행복한 방식으로 전환될 수도 있다는 의미예요.\n하지만 현재로서는 Node.js에서는 패키지 매니저가 필수적이에요. Deno 같은 경우에는 package.json 없이 importmap을 사용하고 있다는 점만 참고해 주세요.\n오늘 패키지 매니저에 대한 라이트닝 토크를 마무리하도록 하겠습니다. 감사합니다!\n\nTalk 박서진 Edit 한주연 Graphic 이나눔\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "monitoring-traffic",
    "title": "서버 증설 없이 처리하는 대규모 트래픽",
    "subtitle": "늘어나는 트래픽을 잘 처리하기 위해 서버 개발자는 어떤 고민을 해야 할까요? “라이브 쇼핑 보기” 서비스에 대규모 트래픽이 들어오면서 겪은 문제와 해결책을 공유드려요.",
    "publishedTime": "2024-05-13T18:11:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/liveshopping-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/liveshopping-thumb.jpg"
    },
    "editor": {
      "name": "함종현",
      "shortDescription": "토스 Server Developer"
    },
    "shortDescription": "안녕하세요. 저는 토스의 광고 제품과 플랫폼을 개발하는 서버 개발자 함종현입니다. 저는 토스에서 라이브 쇼핑 보기 서비스를 담당하고 있어요.\n라이브 쇼핑 보기 서비스란\n라이브 쇼핑 보기는 토스의 “혜택” 탭에 있는 서비스예요. 라이브 쇼핑 보기를 통해서 유저는 상품을 구매하면 포인트를 적립 받을 수 있고, 광고주는 빠르게",
    "fullDescription": "안녕하세요. 저는 토스의 광고 제품과 플랫폼을 개발하는 서버 개발자 함종현입니다. 저는 토스에서 라이브 쇼핑 보기 서비스를 담당하고 있어요.\n라이브 쇼핑 보기 서비스란\n라이브 쇼핑 보기는 토스의 “혜택” 탭에 있는 서비스예요. 라이브 쇼핑 보기를 통해서 유저는 상품을 구매하면 포인트를 적립 받을 수 있고, 광고주는 빠르게 상품 물량을 소진시킬 수 있어요.\n라이브 쇼핑 보기 서비스를 론칭하는 날, 예상했던 것보다 굉장히 많은 유저가 들어왔어요. 그 후에도 매일 신규 유저가 늘었고, 서비스의 성장이 눈에 띄게 보였죠. 그러면서 자연스럽게 라이브 방송하는 광고주도 많아졌습니다.\n\n\n급격하게 성장하는 서비스가 겪는 문제\n이렇게 라이브 쇼핑 보기 서비스는 피크 시간대 동시 접속자 수는 분당 수십만 명, 포인트 지급 요청 API 요청은 초당 수십만 건이 오는 서비스로 성장했는데요. 급격히 늘어난 트래픽은 성장하는 서비스 서버에 치명적일 수 있어요. 서버가 트래픽을 유연하게 처리하지 못하면 유저에게 안 좋은 경험을 제공하고, 최악의 상황에서는 이탈할 수도 있기 때문이에요. \n트래픽이 급격히 늘어나면 쓰레드가 밀리는 것부터 시작해서 데이터베이스와 캐시 시스템, 다른 서버와 같이 사용하는 서버 애플리케이션, 게이트웨이 등에서 장애가 발생할 수 있는데요. Redis와 같은 캐시 서비스의 메모리 사용량이나 CPU 사용량이 늘어나면 캐시가 누락되어 데이터베이스에 큰 부하를 줄 수 있어요. 데이터베이스 장애는 데이터를 오염하거나 다른 서비스의 영향을 줄 수 있고요.\n간단히 서버 증설로 증가한 트래픽을 모두 처리할 수 있다면 가장 좋겠지만 고민해야 하는 점이 몇 가지 더 있습니다. 증설 비용 규모, 그리고 특정 시점에만 트래픽이 몰리면 그 외 시간에는 자원이 낭비될 수 있다는 점이 크고요. 서버 증설 만으로 해결할 수 없는 다른 문제가 생길 수도 있어요.\n늘어나는 트래픽을 잘 처리하기 위해 서버 개발자는 어떤 고민을 해야 할까요?\n\n라이브 쇼핑 서버가 만났던 문제\n먼저 라이브 쇼핑 서버가 겪었던 몇 가지 문제를 소개하고 해결책을 살펴볼게요.\n1. Redis 과부하 문제\n매일 정각에 수십만 명의 유저에게 방송 리스트, 포인트 적립 내역 등을 Redis에 저장하고 읽었는데요. 유저가 늘면서 커맨드와 캐싱하는 데이터 양이 급격히 늘어났어요. CPU가 커맨드를 너무 느리게 처리하거나 데이터가 너무 많으면 Redis에 과부하가 생길 수 있는데요. Redis의 과부하는 데이터베이스의 부하로 이어질 수 있기 때문에 심각한 문제입니다.\nRedis 과부하를 방지하려면 Redis가 캐싱하는 데이터와 읽고 쓰는 시점을 체크해야 하는데요. 먼저 Redis가 캐싱하는 데이터를 두 가지로 분류할 수 있어요. 모든 유저에게 동일하게 보이는 Universal Data와 유저 별로 다르게 사용되는 User-Specific Data입니다. 토스 라이브 쇼핑 서비스에서 전자는 모든 유저가 볼 수 있는 방송 리스트, 방송 상세 정보 등을 캐싱하고 후자는 방송 시청 여부 등을 캐싱합니다.\nUniversal Data 문제 & 해결책\nUniversal Data는 트래픽이 늘어날수록 한 개의 키에서 GET 커맨드가 굉장히 많이 발생하는데요. Redis에 많은 읽기 요청을 보내면 Redis의 CPU가 부하를 겪어요. 이로 인해 Redis의 커맨드 요청이 증가하고 Network IO도 증가합니다. 커맨드가 밀려 Redis에서 지연이 발생할 수 있고, 이는 Redis를 사용하는 모든 곳에서 지연이 발생합니다.\n이러한 문제는 웹 서버에서 Local Cache를 사용해서 Universal Data를 서버 내에서 전부 캐싱하는 방법으로 Redis의 사용량을 줄일 수 있습니다. 또한 Universal Data의 빠른 캐시 초기화가 중요하다면, Redis의 Pub/Sub 기능을 사용해 Local Cache 초기화에 대한 비동기 메시지를 받아 로컬 캐시를 초기화할 수 있어요.\nUser-Specific Data 문제 & 해결책\nUser-Specific Data는 유저가 늘어날수록 캐싱해야 하는 데이터가 많아지고, 데이터의 크기가 커질수록 Redis 메모리 사용량이 늘어난다는 문제가 생길 수 있습니다. 유저가 늘어나면 메모리 사용량이 늘어나는 건 당연하지만, 데이터 하나의 크기가 작아진다면 메모리 사용량도 효과적으로 줄어듭니다.\n즉, Redis에 DTO와 같은 데이터를 저장할 때 다양한 압축 방법을 활용해서 데이터 크기를 최소화해야 합니다. 단, 너무 작은 크기의 데이터를 압축하면 오히려 데이터가 커질 수 있으니 주의해야 해요.\nRedis 과부하로 데이터 처리를 못하게 된다면 Fallback 로직도 고려해야 합니다. 만약 거대한 트래픽이 그대로 데이터베이스에 가게 된다면, 데이터베이스 서버에서 큰 장애가 발생할 수 있기 때문이죠.\n\n\n2. 선착순 포인트 지급과 데이터베이스 과부하 문제\n서비스는 계속 성장하면서 유저 인입도 늘고 광고주들도 더 많은 라이브 쇼핑 광고를 집행했어요. 방송이 많아질수록 더 많은 포인트를 받을 수 있어서 방송이 많은 시간에는 유저가 더 많이 들어오고, 포인트 지급 요청도 더욱 많아졌습니다.\n포인트 지급 요청 기능을 개발할 때는 아래 네 가지 요소를 반드시 고려해야 했습니다.\n한 유저에게 포인트가 중복 지급돼서는 안됩니다.\n유저가 포인트가 지급되었다는 걸 즉시 인지할 수 있어야 합니다.\n포인트가 지급되었다는 걸 토스의 포인트 지급 내역 원장에 기록할 수 있어야 합니다.\n선착순에 들지 못하면 포인트 지급을 하면 안 됩니다.\n첫 번째 문제인 포인트 중복 지급은 간단하게 생각하면 아래와 같은 로직을 적용하여 해결할 수 있습니다.\n포인트 지급 API 요청이 오면 유저에게 포인트가 지급된 후 특정 저장소에 지급되었다는 내역을 생성합니다.\n포인트 지급 API 요청이 오면 특정 저장소에 지급되었다는 내역이 있는지 확인하고, 이미 지급된 경우 지급되지 않도록 분기를 구현합니다.\n간단해보이는 로직이지만 고려할 부분이 꽤 많습니다.\n먼저 API 요청이 연속으로 2개가 들어오는 현상을 막기 위해 RedLock을 통해 API 요청에 대한 Distributed Lock을 걸어 주어야 합니다. 그 이유는 API 요청이 연속으로 2개가 오게 되면, 포인트가 지급되었다는 내역을 저장소에 넣기 전에 각 서버에서 2개의 포인트 지급 요청이 처리되기 때문이에요.\n다음으로 두 번째 문제의 해결 방법인데요. 포인트가 지급 되었다는 걸 즉시 인지하고, 중복 지급 여부에 대해 체크할 수 있도록 Redis와 같은 캐시 시스템에 포인트 적립 내역을 하나의 키에 Append하고, 데이터베이스에 적립 내역을 저장해야 합니다. 데이터베이스에 적립 내역을 바로 넣지 못하는 이유는, 순간적으로 트래픽이 올라갈 때 데이터베이스에서 버틸 수 있는 Insert QPS가 넘어 데이터베이스 과부하로 이어질 수 있어요.\n따라서 데이터베이스에 Insert할 때에는 Kafka를 통해 비동기로 Insert하고, Consumer에서 Throttling을 걸어 최대 QPS에 도달하지 않도록 조절해야 합니다. 지급 내역을 Insert할 때 포인트 지급 내역이 원장에 쌓이기에 이 부분도 해결돼요.\n\n\n마지막으로 선착순 포인트 지급 문제는 Redis에서 지원하는 Increment 커맨드를 통해 리워드 지급 인원을 더하여 지정된 Cap에 도달하였는지 체크하는 방법으로 해결할 수 있습니다. 도달하지 못하였다면 리워드를 지급하고 Increment를 하는 반면, 도달한 경우 리워드를 지급하지 않도록 구현해야 합니다.\n\nRedis는 Single-Thread로 동작하기에 Increment의 경우 Thread-Safe한 동작인데요. 단시간에 너무 많은 Increment 커맨드를 요청하면 Redis의 Thread가 밀려 CPU가 상승해요. 이 부분의 경우 Local Cache에서 Counting한 후 특정 시점에 ScheduleJob으로 Redis에 Flush하는 방법으로 성능 이슈를 개선할 수 있어요. 하지만 이 방법은 Hard하게 Capping하는 방식은 아니어서 서비스에서 추구하는 선착순의 개념과 일치한지 확인해야 합니다.\n\n3. API 중복 요청 및 Gateway 과부하 문제\n\n피크 타임에 라이브 쇼핑 보기 서비스에 트래픽이 너무 많이 올라와서 트래픽을 최소화할 수 있는 방법을 찾던 도중, 중복 요청을 제거하는 것과 API 요청을 1개로 합치는 방법을 적용해 봤어요.\nAPI 중복 요청은 서비스가 성장할수록 큰 독이 됩니다. 피크 트래픽이 커지면 커질수록 중복 요청에서 발생하는 부하는 더더욱 커지게 돼요. 유저 1명에게서 중복 요청이 N개 만큼 오게 되면, 서비스가 성장할수록 의미 없는 중복 요청의 수가 매우 늘어나게 되는데요. 중복 요청은 결국 게이트웨이, 웹서버, Redis, 데이터베이스를 포함해서 한 개의 API 요청을 처리하는 모든 컴포넌트에 부하가 생깁니다.\n특히 중복 요청은 토스 서버로 오는 모든 요청 값과 응답 값을 암호화하는 Gateway에 부하를 발생시키고, 이는 전체 토스 서비스에 영향을 미칠 수 있어요. API 중복 요청은 분석하기가 까다롭고, 해결하기 위해서는 클라이언트 개발자와 지속적으로 소통하면서 서비스와 유저 경험에 영향이 없도록 해야 합니다.\n먼저 중복 요청을 분석하기 위해 라이브 쇼핑 보기 트래픽 중에 API 요청이 가장 많은 유저 ID 기준으로 API 요청 기록을 확인했어요. 그리고 단 시간에 중복으로 요청되는 API가 어떤 상황에서 재현되는지 체크했습니다. 재현된 중복 요청은 클라이언트 개발자와 커뮤니케이션하여 제거하고, 중복 요청을 제거한 후에 서비스에 문제가 없는지, 실제로 API 요청이 눈에 띄게 줄었는지 모니터링했어요.\n\n그리고 API를 합쳐서 응답을 보낼 수 있는 상황이라면, 적극적으로 합쳐야 합니다.\n라이브 쇼핑 보기 서비스에 접속하면 방송 리스트 API, 포인트 지급 예정 API, 공지사항 API 총 3개의 API를 동시에 요청하도록 구현되어 있었는데요. 3개의 API를 동시에 요청하면 피크 트래픽의 규모가 더 커지고, API 요청/응답에서 발생하는 오버헤드가 더 커져요. 또한 Gateway 부하도 늘어납니다.\n해당 API는 한 개의 API 로 묶을 수 있을 수 있어, /view라는 API로 묶었고, 결과적으로 피크 트래픽의 규모를 50%나 줄일 수 있었어요.\n하지만 묶기 어려운 API도 있죠. 응답 시간이 긴 API 의 경우 1개의 API로 합치게 되면 API 응답이 길어지게 되어 문제가 발생할 수 있습니다. 상황에 따라 합칠 수 있는 API는 합치고, 분리해야 하는 API는 분리해서 사용해야 합니다.\n\n성능 개선의 이터레이션\n빠르게 성장하는 서비스라면 앞서 이야기 한 문제 외에도 많은 문제가 생길 수 있는데요. 성능 개선의 이터레이션을 지속적으로 반복하면 문제를 초기에 발견하고 해결해서 서비스 운영에 장애를 막을 수 있습니다.\n서버 모니터링\n문제점 파악\n해결책 제안 및 적용\n카나리 배포 후 서버 모니터링\n위 네 가지를 이터레이션한다면, 서버를 증설하기 전에 다시 한번 증설 여부에 대해 고민할 수 있고, 서버를 증설한 후에 개선이 된다면 많은 리소스가 절약될 수 있어요.\n그 외에도 프로파일러를 통해 성능 모니터링을 지속적으로 하고, 메모리나 연산이 많은 부분을 최적화하면서 서버 리소스를 최적화할 수 있어야 돼요. 또한 중복으로 실행되는 로직이 있는지도 지속적으로 체크하여 불필요한 로직을 모두 없애야 합니다. 그리고 최적화한 버전을 Canary로 배포하면서 장애가 발생하는지, 이전 버전과 비교하여 성능 개선이 유의미한지 모니터링을 해야 합니다.\n맺음말: 모니터링 구축을 기본으로\n성능 개선의 이터레이션을 진행할 때에도 시작과 끝은 모니터링입니다. 제품이 성장할 때 서버 개발자는 모니터링 환경을 먼저 구축해야 합니다. 서버를 포함해서 서버에 연결된 각 컴포넌트(Redis, DB, Kafka 등)와 서비스 지표(PV, UV, 리텐션 등)를 실시간으로 모니터링할 수 있고, 문제가 발생할 수 있는 특정 수준까지 온 경우 Alert 을 줄 수 있도록 말이죠. \n서비스를 사용하는 유저가 장애로 인해 서비스를 사용하지 못하거나 유저 경험이 좋지 않다면, 유저 리텐션이나 신규 유입 지표에서 안 좋은 영향을 미치고, 서비스의 성장을 막을 수 있어요. 또, 서비스가 성장하면서 발생하는 장애를 모니터 할 때 Metric은 원인과 결과를 예상하고 해결책을 제시할 수 있는 매우 중요한 지표입니다.\n성능 개선의 이터레이션을 반복하여 급격하게 성장하는 서비스에서도 장애와 성능 이슈를 유연하게 대처할 수 있길 바랍니다.\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "Redis"
        }
      ]
    }
  },
  {
    "key": "react-native-2024",
    "title": "토스가 꿈꾸는 React Native 기술의 미래",
    "subtitle": "토스 프론트엔드 챕터는 어떻게 React Native 기술을 발전시켜 나갈 예정일까요?",
    "publishedTime": "2024-03-25T17:02:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-common/react-native-thumbnail.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-common/react-native-thumbnail.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "안녕하세요, 토스 프론트엔드 엔지니어링 헤드 박서진입니다.\n토스에서는 최고의 사용자 경험이 필요한 곳은 Native, 매일매일 실험으로 제품을 개선하는 제품은 React Native/WebView로 구성하고 있어요.\n토스 프론트엔드 챕터는 지난 2022년 6월부터 React Native 기술에 투자하고 있는데요. 이번 기",
    "fullDescription": "안녕하세요, 토스 프론트엔드 엔지니어링 헤드 박서진입니다.\n토스에서는 최고의 사용자 경험이 필요한 곳은 Native, 매일매일 실험으로 제품을 개선하는 제품은 React Native/WebView로 구성하고 있어요.\n토스 프론트엔드 챕터는 지난 2022년 6월부터 React Native 기술에 투자하고 있는데요. 이번 기술 블로그 아티클에서는 왜 React Native를 고려하고 있는지, 현재 어느 정도까지 사용하고 있는지, 그리고 앞으로의 계획이 어떻게 되는지에 대해서 소개드리려고 합니다.\n왜 React Native인가\n토스는 React Native로 매끄러운 사용자 경험과 높은 개발 생산성을 제공하여, 모바일 서비스를 만드는 새로운 표준을 제시하고자 해요.\n\n\nReact Native로 서비스를 개발하면, WebView로 서비스를 만들 때보다 사용자 경험을 크게 개선할 수 있어요. React Native는 기본적으로 파일 시스템에서 JavaScript 파일을 읽어오기 때문에, WebView와 다르게 네트워크로 인한 로딩 속도를 없앨 수 있기 때문이죠.\n한국처럼 대부분의 사용자가 2020년 이후에 출시한 최신 핸드폰을 쓰는 환경에서는, JavaScript 실행도 매우 빨라요. 토스에서 “매일 방문 미션” 제품을 React Native로 만들었을 때, 1초 이상의 로딩 속도를 감축시킬 수 있었어요. \n\n특히 앞으로 모바일 기기 성능 발전과 더불어서 JavaScript 실행 속도는 매년 두 자릿수 퍼센티지로 빨라지고, 로딩 시간은 그만큼 계속 줄어들 것으로 보여요. Hermes 엔진으로 JavaScript를 미리 컴파일하면 초기 로딩 속도를 더 빠르게 할 수도 있답니다. (사진 출처)\n\n프론트엔드 개발자의 개발 생산성도 개선할 수 있는데요. \n\n먼저, WebView에서 생산성을 깎는 다양한 문제를 근본적으로 해결할 수 있었어요. 토스는 모바일 서비스를 WebView로 만들면서, 여러 제약이 있다는 것을 알게 되었어요. iOS에서는 display: fixed와 autoFocus 문제가 있었고, Android는 WebView 버전마다 웹 서비스가 다르게 동작하기도 했죠. History도 마음껏 수정하기 어려웠습니다. React Native는 Native 렌더러를 사용하고, 높은 자유도를 제공하기 때문에, 이 문제를 모두 깔끔히 해결할 수 있었어요.\n\n\n또한, 빌드와 배포 속도를 개선할 수 있었어요. 보통 WebView 기반으로 서비스를 만들면 빌드가 느리다는 문제에 맞닥뜨리게 되어요. SSR을 쓰는 경우 서버를 빌드하고 배포하는 시간이 필요하죠. 반면, React Native 기술에서는 배포 단계가 단순해서, 정적인 JavaScript 파일 1개만 빌드하고 업로드하면 돼요. 그래서 배포가 완료되기까지의 시간을 손쉽게 최적화할 수 있죠.\n\n\n마지막으로, 코드의 복잡도도 낮출 수 있었어요. 토스는 100개 넘는 Server-side rendering (SSR) 서비스를 운영하고 있는데요. SSR을 이용하면 기존의 Client-side rendering 접근보다 로딩 속도를 크게 개선하지만, Server와 Client를 넘나드는 Universal한 코드를 작성해야 해요. 두 환경을 모두 고려해야 하기 때문에, 코드의 복잡도가 크게 올라갔죠. 반면, React Native를 이용하면 Client에서 실행되는 경우만 고려하면 되었어요.\n\n토스에서는 사용자 경험과 개발 생산성의 두 가지 가치가 제일 중요한데요. 이렇게 React Native를 이용하면 사용자에게는 더 좋은 경험을 제공하면서도, 개발 생산성도 높일 수 있겠다는 생각이 들었어요.\n토스 React Native 기술의 현재\n토스 프론트엔드 챕터에서는 지난 1년 6개월간 React Native 화면을 조심스럽게 확대해 나가면서, 실제로 토스에서 가치를 제공하는지 확인했어요.\n\n\n토스에서 “혜택 탭”은 React Native로 운영된 첫 번째 서비스로서, 토스에서 광고를 보고 앱테크로 돈을 버는 새로운 표준을 제시했습니다. 매출도 크게 증가했죠. 로딩 속도를 1초 이상 감축했고, 자동 동영상 재생과 같이 기존의 WebView에서 어려웠던 부분을 깔끔히 해결할 수 있었습니다.\n혜택 탭 외로도, 지난 1년간 토스에서는 React Native 서비스를 다수 신규 런칭했어요. “피드 보고 포인트 받기”, “매일 방문 미션”과 같은 다양한 제품이 개발되어 서비스되고 있죠. 덕분에 지금은 React Native 뷰는 WebView를 이용한 화면보다도 많이 실행되고 있어요.\n2024년 토스는 React Native를 서비스를 만들어 나가는 정식 기술 가운데 하나로 사용해보기로 하고, 서비스를 확대해 나가는 단계예요.\nReact Native 개발환경 자세히 살펴보기\n그렇다면 토스에서는 어떻게 React Native 개발환경을 만들어나가고 있을까요?\n마이크로 프론트엔드 아키텍처\n\n\n\n토스에서는 사일로와 서비스마다 독립적으로 서비스를 운영하는 것이 매우 중요해요. 토스는 DRI 문화를 핵심 원칙으로 삼고 있기 때문에, 사일로에서 자체적으로 빠르게 의사결정을 내려서 배포 주기와 방법을 결정해야 하기 때문이죠. 한 서비스의 변경사항이 다른 서비스에게 영향을 주어서도 안 됩니다.\n일반적으로 React Native 애플리케이션은 모놀리식한 단일 파일로 구성되는 경우가 많은데요. 토스에서는 자체적으로 React Native 애플리케이션을 마이크로 프론트엔드 아키텍처로 관리하는 시스템을 만들었습니다.\n\n\n토스에서는 서비스마다 React Native 뷰가 나누어져 있으며, 각 서비스 화면은 독립적으로 실행되어 다른 화면에 영향을 주지 않습니다. 서비스가 실행될 때, 필요한 JavaScript 파일만 동적으로 로드해서 실행하는 형태예요. \n구체적으로는, 토스에서는 React Native 뷰를 그리기 위해 “Shared 번들” 과 “Service 번들”을 나누어 차례대로 실행합니다. “Shared 번들”은 react-native 라이브러리와 같이, 네이티브 영역과 강하게 연결되어 있어, 모든 서비스가 공통으로 사용하는 코드입니다. 그리고 “Service 번들”은 각 서비스에서 다르게 운영하는 부분만 별도로 분리된 코드에요. 두 코드는 서비스가 실행될 때 순서대로 동적으로 로드돼요. 이로써 사용자들은 서비스를 띄울 때 필요한 만큼만의 작은 JavaScript 코드를 실행하게 됩니다.\n이렇게 만들어진 “Shared 번들” 과 “Service 번들” 은 토스의 React Native 플랫폼 팀이 만든 자체적인 어드민을 이용해서 CDN으로 배포돼요. 그리고 서비스 개발자는 간편한 UI로, 1초만에 React Native 화면을 배포하면 되죠.\n1~100% 사이에서 일부 사용자들에게 원하는 만큼 카나리 배포를 할 수도 있고, 나만 보는 배포를 쉽게 만들 수도 있답니다.\nESBuild를 이용한 신속한 배포\n토스에서는 React Native 번들을 빌드하기 위해 Metro 대신 ESBuild 번들러를 사용하고 있어요. Metro 번들러는 빌드하는 데에 시간이 오래 걸리고, Tree-shaking을 지원하지 않으며, 캐시를 리셋하지 않으면 일관적인 동작을 보장하기 어렵기 때문이었습니다. \nESBuild를 도입한 이후에, 빌드 시간을 1분 안쪽으로 줄일 수 있었어요. 번들에서 안 쓰는 코드를 Tree-shaking으로 삭제해서, 번들 사이즈도 크게 감축시켰죠.\n자세한 내용은 2023년 FEConf에서 “React Native, Metro를 넘어서” 발표에서 확인하실 수 있어요.\n\n\nReact Native의 미래\n토스 프론트엔드 챕터는 React Native 기술의 미래가 밝다고 생각해요. 과거 React Native 기술에 대한 인식이 좋지 않았을 때도 있었지만, React Native 커뮤니티가 지속적으로 유의미한 발전을 만들고 있다고 보고 있습니다.\n먼저, React Native 애플리케이션은 시간이 갈수록 자연스럽게 빨라지고 있어요. 스마트폰이 JavaScript를 실행하는 속도가 계속 빨라지고 있기 때문이죠. 하나의 예시로, 유명한 채팅 앱인 Discord는 iOS와 Android 모두 React Native로 구성되어 있는데요. 놀라울 정도로 빠른 성능과 아름다운 사용성을 보여주고 있어요. 그 외로 Microsoft가 제공하는 Office 앱이나, Shopify, Amazon 같은 사례도 있답니다. \n최근 Meta에서는 react-strict-dom (RSD) 이라고 하는 오픈소스 프로젝트를 발표했는데요. 하나의 코드베이스로 React와 React Native를 연결하려고 하는 비전을 제시하고 있어요. 마찬가지로 토스에서도 Web과 React Native에서 모두 아름답고 안정적으로 동작하는 “Isomorphic Package” 을 만들어 나가려고 해요.\n\nMeta가 공개한 또다른 오픈소스 프로젝트로는 Static Hermes가 있어요. JavaScript를 바이너리로 컴파일함으로써 실행 속도를 네이티브와 동일한 수준으로 맞추려는 담대한 목표를 가지고 있죠. \n또한, 2024년 React Conf는 Meta와 React Native 전문 오픈소스 회사 Callstack이 협업해서 열리는데요. 아직 자세한 발표 내용이 공개되지는 않았지만, React Native를 주제로 하는 발표가 다수 예정되어 있어요. React Native는 앞으로 React Server Components와 함께 React 커뮤니티의 가장 중심적인 주제 중 하나가 될 것이라고 생각해요.\n토스의 React Native Platform Team에서 일하기\n토스에는 React Native Platform Team이 있어요. 프론트엔드 플랫폼 개발자 3명과 iOS 개발자 1명으로 구성되어 있고, 지금은 Android 개발자를 찾고 있어요. \n모든 팀원이 각자의 분야에 대한 전문가로 구성되어 있어요. 이근혁님은 React Native를 ESBuild로 빌드하는 react-native-esbuild 프로젝트를 오픈소스화하고 토스에 합류하셨어요. 오진성님은 iOS 분야의 전문가로, Cocoapods 없이 React Native를 앱에 포함하는 구조를 설계하셨죠. 기술적인 배경은 다르지만, 모두가 본인의 주된 개발 언어에 관계없이 주도적이고 열정적으로 프로젝트에 참여하고 있어요.\n\nReact Native Platform Team의 특징이라고 한다면, 모두가 전문 분야에 관계없이 JavaScript, iOS, Android 모든 영역을 담당하는 것을 지향한다는 점이에요. 프론트엔드 개발자도 iOS, Android 영역에 기여하고, 네이티브 개발자도 JavaScript 영역에 기여하려고 하죠. 프론트엔드와 네이티브 개발자가 다양한 도메인에 소프트랜딩할 수 있도록, 서로가 서로를 온보딩하고, 매일같이 모여서 짝 프로그래밍을 하는 문화를 가지고 있어요. 모두가 iOS, Android, JavaScript 등 클라이언트 개발 전반에 대한 전문성을 확보하려고 하고 있습니다.\n대표적인 예시로, iOS 개발자도 React Native의 TDS(디자인 시스템) 라이브러리에 기여하고 있고, 프론트엔드 개발자도 iOS, Android의 React Native 모듈 유지보수에 참여하여 PR을 올리고 있어요.\n\nReact Native는 iOS와 Android, JavaScript 개발환경에 대한 이해가 없으면 다루기 힘든 기술인데요. 토스에는 국내 최고 수준으로 JavaScript, iOS, Android를 다루는 엔지니어들이 모여 있어요. 덕분에 어려운 문제를 맞닥뜨렸다고 하더라도, 각 플랫폼의 전문가와 함께 토론하면서 배워가고, 해결할 수 있죠. 치열하게 고민하며 최고의 개발환경을 만들어 나가는 짜릿함을 느끼고 있어요.\n이렇게 토스의 React Native Platform Team은, 쫀득한 사용자 경험과 슬릭한 개발 생산성 모두를 제공하는 개발환경을 주도적으로 만들어 나갈 예정이에요.\n무엇보다, 토스의 React Native 플랫폼은 여기에 그치지 않고, 올해 안에 지금까지 만든 React Native 배포 모듈과 AWS 인프라를 오픈소스화하고, 세계적으로 앱을 만들어 나가는 Best Practice를 제시하는 것이 목표예요.\n\n최고의 개발환경에서 React Native 서비스를 만들어 나가고 싶으신가요? Frontend Developer로 합류하시면, 토스의 React Native 개발환경을 경험할 수 있답니다.\nReact Native Platform Team에서 개발환경을 가꾸어 나가는 여정에 함께하고 싶으신가요? Frontend Platform Engineer나 Android Developer (React Native) 에 지원하시면 팀에 합류하실 수 있어요.\n\n그러면 앞으로 토스가 보여줄 React Native 개발환경을 기대해주세요!\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "React Native"
        }
      ]
    }
  },
  {
    "key": "docs-engineering",
    "title": "더 자유롭고, 빠르고, 정확하게: 토스페이먼츠 API 문서 엔지니어링",
    "subtitle": "MDX, OAS, remark를 활용한 토스페이먼츠의 API 문서 엔지니어링에 대해 소개해요.",
    "publishedTime": "2024-03-20T08:52:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/payments-docu-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/payments-docu-thumb.jpg"
    },
    "editor": {
      "name": "한주연/신지호",
      "shortDescription": "토스페이먼츠 DX(Developer eXperience) 팀"
    },
    "shortDescription": "다른 회사나 서비스에서 만든 API를 사용해 본 경험이 있으신가요? 복잡한 API를 파악하거나 새로운 업데이트를 적용하려고 할 때 설명이 정확하지 않다면 API를 적용하는 데 어려움을 겪죠. 그래서 API를 외부 개발자에게 제공할 때, 명확하고 쉽게 이해할 수 있는 문서는 필수적이에요.\n토스페이먼츠는 최고의 문서 경험을 ",
    "fullDescription": "다른 회사나 서비스에서 만든 API를 사용해 본 경험이 있으신가요? 복잡한 API를 파악하거나 새로운 업데이트를 적용하려고 할 때 설명이 정확하지 않다면 API를 적용하는 데 어려움을 겪죠. 그래서 API를 외부 개발자에게 제공할 때, 명확하고 쉽게 이해할 수 있는 문서는 필수적이에요.\n토스페이먼츠는 최고의 문서 경험을 ",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "Technical Writing"
        }
      ]
    }
  },
  {
    "key": "engineering-note-9",
    "title": "프론트엔드 배포 시스템의 진화 (1) - 결제 SDK에 카나리 배포 적용하기",
    "subtitle": "토스페이먼츠 SDK 팀에서 카나리 배포를 프론트엔드 제품에 적용하면서 개발자들의 배포 경험을 개선한 사례를 소개해요.",
    "publishedTime": "2024-03-05T20:37:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/progressive-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/progressive-thumb.jpg"
    },
    "editor": {
      "name": "라웅배",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "엔지니어링 노트 9: 프론트엔드 배포 시스템의 진화 (1) - 결제 SDK에 카나리 배포 적용하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 토스페이먼츠 SDK 팀에서 카나리 배포를 프론트엔드 제품에 적용하면서 개발자들의 배포 경험을 개선한 ",
    "fullDescription": "엔지니어링 노트 9: 프론트엔드 배포 시스템의 진화 (1) - 결제 SDK에 카나리 배포 적용하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 토스페이먼츠 SDK 팀에서 카나리 배포를 프론트엔드 제품에 적용하면서 개발자들의 배포 경험을 개선한 ",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "restructuring",
    "title": "달리는 기차의 바퀴 교체하기 2. Restructuring",
    "subtitle": "이미 운영 중인 제품을 전부 갈아엎고 다시 만드는 경험을 하기는 어려운데요. 운 좋게 팀 내 공감대가 형성되어 여러 팀원과 하나의 제품을 온전히 개선해 볼 수 있었어요. 앞선 내용에 이어서 이 글에서는 구체적으로 어떻게 개선했는지 소개할게요.",
    "publishedTime": "2024-02-23T09:30:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/train-payments-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/train-payments-thumb.jpg"
    },
    "editor": {
      "name": "한재엽",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "앞선 글 1. Planning에선 문제를 어떻게 정의하는지에 대해 다뤘어요. 구체적인 내용을 기약하고 글을 마무리했는데요, 이 글에선 구체적으로 어떤 작업들을 진행했는지 소개해요.\n재구조화\n앞선 글에서 소개했듯이 '재구조화'라는 단어는 리팩토링보다 좀 더 거시적인 관점에서의 개선을 뜻해요. 이번 프로젝트에서는 테스트 코드",
    "fullDescription": "앞선 글 1. Planning에선 문제를 어떻게 정의하는지에 대해 다뤘어요. 구체적인 내용을 기약하고 글을 마무리했는데요, 이 글에선 구체적으로 어떤 작업들을 진행했는지 소개해요.\n재구조화\n앞선 글에서 소개했듯이 '재구조화'라는 단어는 리팩토링보다 좀 더 거시적인 관점에서의 개선을 뜻해요. 이번 프로젝트에서는 테스트 코드",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "테스트"
        },
        {
          "content": "리팩토링"
        }
      ]
    }
  },
  {
    "key": "engineering-note-8",
    "title": "OpenZFS로 성능과 비용, 두 마리 토끼 잡기",
    "subtitle": "토스페이먼츠 DevOps 엔지니어가 스토리지 파일 시스템을 OpenZFS로 변경하면서 성능은 높이고 비용은 절감한 과정을 소개합니다.",
    "publishedTime": "2024-02-20T11:45:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/test-thumb-2.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/test-thumb-2.jpg"
    },
    "editor": {
      "name": "박명순",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "엔지니어링 노트 8: OpenZFS로 성능과 비용, 두 마리 토끼 잡기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 토스페이먼츠 DevOps 엔지니어가 스토리지 파일 시스템을 OpenZFS로 변경하면서 성능은 높이고 비용은 절감한 과정을 소개합",
    "fullDescription": "엔지니어링 노트 8: OpenZFS로 성능과 비용, 두 마리 토끼 잡기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 토스페이먼츠 DevOps 엔지니어가 스토리지 파일 시스템을 OpenZFS로 변경하면서 성능은 높이고 비용은 절감한 과정을 소개합",
    "seoConfig": {
      "tags": [
        {
          "content": "DevOps"
        }
      ]
    }
  },
  {
    "key": "cache-traffic-tip",
    "title": "캐시 문제 해결 가이드 - DB 과부하 방지 실전 팁",
    "subtitle": "대용량 트래픽 환경에서 캐시를 사용할 때 주의해야할 위험 상황과 예방법을 소개합니다.",
    "publishedTime": "2024-02-15T17:20:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/app-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/app-thumb.jpg"
    },
    "editor": {
      "name": "김신",
      "shortDescription": "토스 Server Developer"
    },
    "shortDescription": "데이터베이스는 시스템을 확장하기 어려워요. 주로 샤딩과 복제를 통해 어렵게 확장해야 하는데다가, 이 과정에서 일관성, 가용성, 분할 내성 셋을 모두 만족시킬 수 없다는 점이 널리 알려져 있죠(CAP 이론). 그래서 데이터베이스를 확장할 때는 신중해야 돼요.\n가급적 데이터베이스의 부하를 최소화하여 확장 필요성을 줄이는 것이",
    "fullDescription": "데이터베이스는 시스템을 확장하기 어려워요. 주로 샤딩과 복제를 통해 어렵게 확장해야 하는데다가, 이 과정에서 일관성, 가용성, 분할 내성 셋을 모두 만족시킬 수 없다는 점이 널리 알려져 있죠(CAP 이론). 그래서 데이터베이스를 확장할 때는 신중해야 돼요.\n가급적 데이터베이스의 부하를 최소화하여 확장 필요성을 줄이는 것이 바람직한데요. 이를 위한 기본적인 접근법은 데이터베이스 조회 이전에 캐시를 먼저 확인하는 것입니다. 높은 캐시 히트율을 유지하면 데이터베이스 확장 없이도 상당한 트래픽을 처리할 수 있어요.\nRedis나 Memcached와 같은 인메모리 저장소로 캐시 시스템을 많이 구축합니다. 사용하기 쉬운 데다가 응답 속도가 빠르기 때문인데요. 특히 Redis는 온라인에서 다양한 활용 사례를 쉽게 찾을 수 있어서 안정적인 운영이 가능하기도 하고요.\n하지만 대용량 트래픽 환경에서 캐시를 사용하려면 몇 가지 주의해야 할 상황이 있어요. 이 글은 캐시를 사용해도 데이터베이스 부하로 인해 서비스 장애가 발생할 수 있는 위험 상황들을 설명하고 이를 예방하는 방법을 소개해요.\n1.  캐시 쇄도(Cache Stampede)\n\n캐시 미스가 동시에 많이 발생하면 데이터베이스에 부담이 가중돼요. '캐시 쇄도'라고 부르는 상황인데, 캐시가 전부 정확히 같은 시간에 만료되도록 구현하면 자주 발생하고요.\n예를 들어, 매일 자정에 캐시를 갱신한다고 생각해 볼게요. 갱신 시간에 맞춰 캐시가 일제히 만료되도록 설계하는 것은 구현하기 쉬운 데다가 최신 정보를 바로 제공할 수 있다는 이점이 있어요. 하지만 이런 캐시 만료 전략은 캐시가 만료되는 자정마다 데이터베이스로 트래픽이 집중되어 서비스 장애가 발생할 위험도 있어요.\n해결안: 지터(Jitter)\n캐시 만료 시간을 무작위로 조금 지연시키면, 캐시 쇄도 상황에서도 데이터베이스의 부하를 균등하게 분산시킬 수 있어요.\n전자공학에서 사용되는 '지터(Jitter)' 개념을 활용하는 건데요. 지터는 전자 신호를 읽는 과정에서 발생하는 짧은 지연 시간을 의미해요. 우리는 지터처럼 짧은 시간을 캐시 만료 시간에 더해서 부하를 분산시킬 수 있어요. 예를 들어 0~10초 사이의 무작위 지연 시간을 추가하면, 데이터베이스의 부담이 10초에 걸쳐 분산되는 것이죠.\n서비스마다 허용할 수 있는 지연 시간은 다르기 때문에, 서비스에 적절한 최대 지터 시간을 설정해야 돼요. 지터가 길어질수록 사용자는 더 오래된 정보를 볼 수 있으므로, 지터가 과도하게 추가되지 않도록 주의해야 합니다.\n2. 캐시 관통(Cache Penetration)\n\n보통 캐시에서 null 값이 반환되면 자연스럽게 데이터베이스를 조회해서 캐시를 채워요. 그런데 데이터베이스에도 해당 값이 없어서 null을 반환받았을 때는 캐시를 채우지 않도록 구현하는 경우가 흔해요. 데이터베이스로부터 반환받은 '값이 없다'라는 정보를 캐싱하지 않으면 어떤 위험이 있을까요?\n데이터베이스에서 읽었는데도 캐싱 되지 않는 상황을 '캐시 관통'이라고 합니다. 캐시 관통이 빈번하다면, 데이터베이스에 불필요한 조회 요청이 자주 발생해요. 따라서 데이터가 없다는 사실도 캐싱해야 불필요한 데이터베이스 부하를 줄일 수 있어요.\n해결안: 널 오브젝트 패턴(Null Object Pattern)\n‘값이 없음’을 캐싱함으로써 데이터베이스의 트래픽을 줄이려면 블룸 필터를 사용하는 것도 좋은 방법입니다. 블룸 필터를 사용하면 확률적으로 캐시 관통을 방지해요. 하지만 블룸 필터의 정합성이 깨진다면, 블룸 필터를 복구하기 위해 모든 캐시를 읽어야 해서 운영이 어려워요.\n널 오브젝트 패턴을 사용해서 ‘값이 없음’을 캐싱하는 방법이 운영하기 더 쉬워요. 객체 타입은 부재를 뜻하는 객체를 선언하여 사용하면 되지만, 원시 타입은 이 객체를 대체할 특정 값을 지정해야 돼요. 예를 들어, 양수만 존재하는 정수 타입의 데이터를 캐시할 때는 음수인 정수의 최솟값으로 '값이 없음'을 나타내기로 애플리케이션에서 약속할 수 있어요.\n3. 캐시 시스템 장애\n\n평이한 트래픽 상황에서는 캐시 시스템에 장애가 발생하더라도 데이터베이스로 트래픽을 보내면 서비스를 정상 운영할 수 있어요. 하지만 트래픽이 큰 상황이라면 캐시 시스템이 복구될 때까지 데이터베이스에 과부하가 걸릴 위험이 있어요.\n데이터베이스가 모든 트래픽을 감당할 수 있다고 낙관하는 것은 위험한 생각이에요. 데이터베이스가 한계를 넘는 트래픽을 받으면, 캐시와 무관한 기능조차 정상적으로 작동하지 못할 수 있어요. 따라서 데이터베이스가 감당할 수 있는 범위의 트래픽을 유지하도록 계획을 세워야 합니다.\n해결안: 대체 작동(Failover)\n캐시 시스템 결함에 의한 장애를 최소화하기 위해서는 핵심 기능을 정의할 필요가 있어요. 캐시 시스템이 망가졌다면 반드시 동작해야 되는 핵심 기능을 제외하고, 편의를 위한 부가 기능은 일시적으로 운영을 중단하는 게 낫습니다. 캐시 시스템이 복구되는 동안 데이터베이스가 핵심 기능으로 트래픽을 처리할 수 있고, 부가 기능은 사용자에게 대체 UI를 제공하거나 양해를 구하는 게 현실적인 대응 방법입니다. \n캐시 코드를 공통화 하다보면 기능의 중요도를 따지지 않고, 데이터베이스로 fallback하는 코드를 작성하기 쉬워요. 데이터베이스 부하를 감안하더라도 꼭 동작해야할 기능인지 개발자가 미리 고민할 필요가 있습니다.\n4. 핫(Hotkey) 만료\n\n많은 요청이 집중되는 키를 '핫키'라고 하는데요. 핫키가 만료되는 순간, 여러 요청이 동시에 데이터베이스를 불필요하게 반복해서 조회할 수 있어요. 가능하다면 캐시의 만료 기한을 없애거나, 백그라운드에서 주기적으로 새 값을 적용해서 캐시가 만료되지 않게 하는 것이 좋습니다. 하지만 핫키가 때에 따라 바뀌는 환경에서는 더 이상 핫키가 아닌 데이터로 인해 캐시 저장소 공간이 낭비될 수 있어요.\n해결안: 분산 락(Distributed Lock)\n분산 락을 사용하면 공간 낭비 없이 불필요한 데이터베이스 중복 조회를 방지할 수 있어요. 멀티 스레드 프로그래밍에서 공유 자원 다룰 때 락을 사용하는 것과 비슷한 원리인데요. 캐시를 애플리케이션 서버 간의 공유 자원으로 볼 수 있습니다. 캐시 미스가 발생했을 때 락을 설정하고 캐싱한 후에 락을 해제함으로써, 단 한 번의 쓰기 작업만 허용할 수 있고요.\nRedis를 사용하고 있다면 분산 락을 적용하기 굉장히 쉬워요. Redis의 싱글 스레드 특징을 활용한 레드락 알고리즘 덕분인데요. 다양한 프로그래밍 언어를 지원하는 레드락 구현 라이브러리들이 존재해요. 이 라이브러리들을 사용하면 분산 환경에서도 공유 자원을 효과적으로 관리할 수 있어요. Redis 없이도 분산 락을 구현할 방법은 다양하므로, 핫키 만료 상황에서 분산 락을 이용하면 캐시 히트율을 유지할 수 있습니다.\n정리\n이 글에서는 데이터베이스 부하 방지를 위한 캐시 시스템의 도전과제들을 다뤘으며, 이에 대한 몇 가지 해결책을 모색해 봤어요. 모든 상황에 완벽하게 적용될 수는 없겠지만, 적어도 일부 문제를 해결하거나 완화하는 데는 도움 되길 바랍니다.\n데이터베이스와 캐시 시스템의 상호작용은 예측하기 어려워요. 그래서 제시된 아이디어를 실제로 적용할 때는 더 다양한 요소들을 고려해야 합니다. 모든 환경에서 효과적이지는 않지만 이런 아이디어들이 캐시로 인한 문제들을 인식하고, 해결 방안을 고려하는 데 시작점이 되기를 바래요.\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Data"
        },
        {
          "content": "Redis"
        }
      ]
    }
  },
  {
    "key": "25431",
    "title": "GitHub Actions로 개선하는 코드 리뷰 문화",
    "subtitle": "자동화를 통해 코드 리뷰 문화를 개선하고 편의를 높였던 경험을 공유해요.",
    "publishedTime": "2024-02-07T10:22:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/automation-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/automation-thumb.jpg"
    },
    "editor": {
      "name": "김성일",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "토스페이먼츠는 결제의 다양한 맥락을 다루는 회사이기 때문에 코드 변경과 배포가 신중하게 이루어져야 하는데요. 이런 상황에서 코드 리뷰는 서비스의 안정성을 높일 수 있는 효과적인 방법 중 하나죠. 제가 속한 온보딩 플랫폼 팀에서도 코드 리뷰를 진행하고 있지만, 보다 면밀한 리뷰와 피드백 공유가 필요한 상황이었어요.\n저는 코",
    "fullDescription": "토스페이먼츠는 결제의 다양한 맥락을 다루는 회사이기 때문에 코드 변경과 배포가 신중하게 이루어져야 하는데요. 이런 상황에서 코드 리뷰는 서비스의 안정성을 높일 수 있는 효과적인 방법 중 하나죠. 제가 속한 온보딩 플랫폼 팀에서도 코드 리뷰를 진행하고 있지만, 보다 면밀한 리뷰와 피드백 공유가 필요한 상황이었어요.\n저는 코",
    "seoConfig": {
      "tags": [
        {
          "content": "자동화"
        },
        {
          "content": "문화"
        }
      ]
    }
  },
  {
    "key": "tech-writer-2",
    "title": "그 많은 개발 문서는 누가 다 만들었을까 (2) 개발자의 학습을 돕는 모든 것",
    "subtitle": "토스의 테크니컬 라이터가 하는 일에 이어, 개발자 경험 전반으로 역할을 확장해 온 이야기를 공유해요.",
    "publishedTime": "2024-01-25T09:30:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/writer-2-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "한주연",
      "shortDescription": "토스페이먼츠 Technical Writer"
    },
    "shortDescription": "지난 콘텐츠에서는 테크니컬 라이터의 역할과 그동안 해왔던 일을 중점적으로 소개해 드렸어요. 이번 콘텐츠에서는 토스의 테크니컬 라이터가 개발자 경험 전반으로 역할을 확장해 온 이야기를 공유해요.\n개발자 경험(Developer eXperience)이란?\n‘개발자경험’에 대해 들어보신 적 있나요? 이제 친숙한 개념이 된 UX(",
    "fullDescription": "지난 콘텐츠에서는 테크니컬 라이터의 역할과 그동안 해왔던 일을 중점적으로 소개해 드렸어요. 이번 콘텐츠에서는 토스의 테크니컬 라이터가 개발자 경험 전반으로 역할을 확장해 온 이야기를 공유해요.\n개발자 경험(Developer eXperience)이란?\n‘개발자경험’에 대해 들어보신 적 있나요? 이제 친숙한 개념이 된 UX(",
    "seoConfig": {
      "tags": [
        {
          "content": "Technical Writing"
        }
      ]
    }
  },
  {
    "key": "tech-writer-1",
    "title": "그 많은 개발 문서는 누가 다 만들었을까 (1) 토스페이먼츠 테크니컬 라이터가 하는 일",
    "subtitle": "토스 커뮤니티의 테크니컬 라이터들은 개발자를 위한 문서를 쓰는 것뿐만 아니라, 멋진 개발자 경험을 제공하기 위해 다양한 일을 하고 있답니다.",
    "publishedTime": "2024-01-23T18:52:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/writer-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/writer-thumb.jpg"
    },
    "editor": {
      "name": "한주연",
      "shortDescription": "토스페이먼츠 Technical Writer"
    },
    "shortDescription": "안녕하세요, 저는 토스페이먼츠 테크니컬 라이터 한주연입니다. 지난 3년 동안 토스페이먼츠와 토스 커뮤니티에서 테크니컬 라이터로 일을 해왔는데요. 토스 커뮤니티의 테크니컬 라이터들은 개발자를 위한 문서를 쓰는 것뿐만 아니라, 멋진 개발자 경험을 제공하기 위해 다양한 일을 하고 있답니다. 이번 시리즈에서는 테크니컬 라이터의 ",
    "fullDescription": "안녕하세요, 저는 토스페이먼츠 테크니컬 라이터 한주연입니다. 지난 3년 동안 토스페이먼츠와 토스 커뮤니티에서 테크니컬 라이터로 일을 해왔는데요. 토스 커뮤니티의 테크니컬 라이터들은 개발자를 위한 문서를 쓰는 것뿐만 아니라, 멋진 개발자 경험을 제공하기 위해 다양한 일을 하고 있답니다. 이번 시리즈에서는 테크니컬 라이터의 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Technical Writing"
        }
      ]
    }
  },
  {
    "key": "engineering-note-7",
    "title": "Spring JDBC 성능 문제, 네트워크 분석으로 파악하기",
    "subtitle": "토스페이먼츠 정산 플랫폼에서 많은 양의 정산 데이터 처리 과정에서 생긴 지연 이슈를 처리한 방법을 소개해요.",
    "publishedTime": "2024-01-17T10:55:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/spring-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/spring-thumb.jpg"
    },
    "editor": {
      "name": "강민주",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "엔지니어링 노트 7: Spring JDBC 성능 문제, 네트워크 분석으로 파악하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 토스페이먼츠 정산 플랫폼에서 많은 양의 정산 데이터 처리 과정에서 생긴 지연 이슈를 처리한 방법을 소개해요.\n\n토스페",
    "fullDescription": "엔지니어링 노트 7: Spring JDBC 성능 문제, 네트워크 분석으로 파악하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 토스페이먼츠 정산 플랫폼에서 많은 양의 정산 데이터 처리 과정에서 생긴 지연 이슈를 처리한 방법을 소개해요.\n\n토스페이먼츠 정산 플랫폼에서는 가맹점의 모든 정산 거래 건을 처리하고 있는데요. 많은 양의 정산 데이터 처리를 위해 스프링 배치(Spring Batch)와 JDBC(Java Database Connectivity)를 사용해요. 최근 신규 정산 시스템을 구현하는 과정에서 문제가 있었는데요. 스프링 배치 내에서 JDBC로 대량의 데이터 insert가 이루어질 때 속도가 지연되는 현상이었어요. 문제 현상의 원인을 찾고 해결한 과정을 공유합니다.\nbulk insert 성능 저하 현상 발견\nJDBC 템플릿은 스프링에서 제공하는 데이터베이스 연결 및 작업을 쉽게 할 수 있도록 하는 도구인데요. 템플릿에서 제공하는 batchUpdate()는 여러 개의 데이터베이스 업데이트(예: insert, update) 명령을 한 번에 묶어서 처리합니다. 이를 'bulk insert'라고 부르는데요. 많은 양의 데이터를 데이터베이스에 삽입하는 작업이에요.\nJDBC를 이용해 bulk insert를 하기 위해 다음처럼 Repository 코드를 작성합니다.\n@Component\nclass SettlementStepRepository(\n  @Qualifier(\"settlementJdbcTemplate\")\n    private val jdbc: NamedParameterJdbcTemplate,\n) {\n  @Transactional\n    fun insertAll(steps: List<SettlementStep>) {\n      val namedParameters = steps.map { it.toSqlParam() }\n      jdbc.batchUpdate(\n        \"\"\" \n          INSERT INTO SETTLEMENT_STEP\n          (....) \n          VALUES \n          (....)\n          \"\"\".trimIndent(),\n        namedParameters.toTypedArray(),\n      ) \n    }\n//...\n정말 흔하게 볼 수 있는 batchUpdate를 활용한 대량 insert 구현체에요. 그런데 이 Repository를 이용해 구현한 스프링 배치 ItemWriter에서 5000개의 객체를 삽입할 때 무려 1분 이상이 걸리는 현상을 발견했습니다.\n문제 원인 찾기\n1. TCP 패킷 분석\n처음에는 지연 원인을 찾기가 어려웠습니다. 다른 로직 없이 단순히 데이터를 삽입하는 Writer 단계였기 때문이죠. 막연하게 데이터 삽입 작업을 블로킹하는 로직이 배치 내에서 돌고 있다는 느낌은 있었지만, 내부 어플리케이션 로그에서는 문제를 발견할 수 없었어요. 그래서 JDBC에서 실행되는 쿼리를 확인하기 위해 로그 레벨을 변경해 봤어요. 데이터베이스와의 상호작용 중에 발생하는 모든 쿼리를 기록해 본 거죠. 하지만 이 방법으로도 insert 쿼리 외에 다른 쿼리는 발견되지 않았어요. 즉, 지연의 원인이 insert 쿼리 자체는 아닌 것 같았어요.\n복잡한 로직이 없는데도 지연 문제가 발생한다면 데이터베이스와의 통신 중에 어떤 블로킹이 발생한 게 아닐까 추측했어요. 그래서 TCP 패킷 캡쳐(네트워크를 통해 전송되는 데이터 패킷을 포착하여 분석하는 것)를 하기로 했어요. 데이터베이스와 배치 프로그램 간에 실제로 어떤 쿼리를 주고받는지 확인하기 위해서였죠.\nWireShark라는 프로그램을 통해 로컬 데이터베이스 호스트에 연결하면, 해당 호스트를 통해 주고받는 모든 TCP 패킷을 확인할 수 있습니다. 캡쳐링한 TCP 패킷은 follow TCP Stream 기능을 사용하면 쉽게 읽을 수 있는 형태로 스트림을 재조립해 줘요.\n\nWireshark를 세팅한 후 배치를 실행해 보니, 놀라운 결과가 나왔습니다. bulk insert 쿼리가 실행되기 전에 해당 데이터베이스 테이블에 대한 select 쿼리가 다량으로, 계속해서 실행되고 있었거든요.\n2. JDBC 코드 디버깅\nselect 쿼리가 실행된 이유를 알아내기 위해 JDBC의 NamedJdbcTemplate 클래스의 batchUpdate 함수를 디버깅 해봤어요. 전체 디버깅 흐름은 아래와 같아요.\n\n구현할 때 사용한 batchUpdate()는 JdbcTemplate 내 setValues()을 오버라이딩 해서 JdbcTemplate.batchUpdate()를 그대로 호출합니다.\n오버라이딩한 setValue()를 살펴보니PreparedStatementCreatorFactory의 setValues()에서 문제가 발생하고 있었어요.\nPreparedStatementCreatorFactory의 setValues() 내부에서는StatementCreatorUtils의 setParameterValue() 메서드를 실행하고 있었습니다.\n// NamedJdbcTemplate.java\n\n@Override\n  public int[] batchUpdate(String sql, SqlParameterSource[] batchArgs) {\n    if (batchArgs.length == 0) {\n      return new int[0];\n    }\n\n    ParsedSql parsedSql = getParsedSql(sql);\n    PreparedStatementCreatorFactory pscf = getPreparedStatementCreatorFactory(parsedSql, batchArgs[0]);\n    \n    // 여기서 this.getJdbcOperations()은 JdbcTemplate 객체를 반환\n    return getJdbcOperations().batchUpdate(\n      pscf.getSql(),\n      new BatchPreparedStatementSetter() {\n        @Override\n        public void setValues(PreparedStatement ps, int i) throws SQLException {\n          Object[] values = NamedParameterUtils.buildValueArray(parsedSql, batchArgs[i], null);\n          pscf.newPreparedStatementSetter(values).setValues(ps);\n        }\n        @Override\n        public int getBatchSize() {\n          return batchArgs.length;\n        }\n    });\n\t}\n// PreparedStatementCreatorFactory.java\n@Override\n  public void setValues(PreparedStatement ps) throws SQLException {\n    // Set arguments: Does nothing if there are no parameters.\n    int sqlColIndx = 1;\n    for (int i = 0; i < this.parameters.size(); i++) {\n      Object in = this.parameters.get(i);\n      SqlParameter declaredParameter;\n      // ...\n\n      if (in instanceof Iterable && declaredParameter.getSqlType() != Types.ARRAY) {\n        // ...\n      } else {\n        StatementCreatorUtils.setParameterValue(ps, sqlColIndx++, declaredParameter, in);\n      }\n    }\n  }\nStatementCreatorUtils의 setParameterValue()는 내부에서 setParameterValueInternal()를 호출하는데, 이 함수는 PreparedStatement에 인자로 넘긴 값을 어떻게 세팅할지 결정하는 로직을 담고 있습니다. \nPreparedStatement는 데이터베이스에 SQL 쿼리를 보내기 전에 SQL 문을 미리 준비하고 매개변수화하는 객체에요.\n// StatementCreatorUtils.java\nprivate static void setParameterValueInternal(PreparedStatement ps, int paramIndex, int sqlType,\n  @Nullable String typeName, @Nullable Integer scale, @Nullable Object inValue) throws SQLException {\n\n  String typeNameToUse = typeName;\n  int sqlTypeToUse = sqlType;\n  Object inValueToUse = inValue;\n\n  // override type info?\n  if (inValue instanceof SqlParameterValue) {\n    //...\n    inValueToUse = parameterValue.getValue();\n  }\n\n  if (logger.isTraceEnabled()) {\n    logger.trace(\"Setting SQL statement parameter value: column index \" + paramIndex +\n      \", parameter value [\" + inValueToUse +\n      \"], value class [\" + (inValueToUse != null ? inValueToUse.getClass().getName() : \"null\") +\n      \"], SQL type \" + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? \"unknown\" : Integer.toString(sqlTypeToUse)));\n  }\n\n  if (inValueToUse == null) {\n    setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse);\n  } else {\n    setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse);\n  }\n}\n문제는 넘긴 값으로 null이 들어갈 때였어요. 만약 인자로 들어가는 값이 null이면, 해당 값은 inValueToUse라는 지역 변수를 null로 설정하고, setNull() 이라는 내부 함수를 실행해요.\nsetNull() 함수 내에서 문제가 된 부분은 세팅하는 값이 null일 때 이 값에 대응하는 SqlType을 JDBC가 알 수 없다는 거였어요. SqlType은 JDBC에서 사용하는 데이터 타입을 정의하는데요. PreparedStatement에서 해당 값을 어떻게 세팅할지 알 수 없어서 직접 데이터베이스로부터 타입 정보를 가져오려고 시도한 거죠.\n즉, null 값을 처리할 때 필요한 데이터 타입 정보를 데이터베이스로부터 가져오는 이 추가 작업이 성능 저하를 일으켰던 거예요.\nsetNull 함수가 성능에 미치는 영향\n아래 코드를 보면서 setNull 함수를 좀 더 자세히 살펴볼게요. 함수 내에서 shouldIgnoreGetParameterType 조건에 따라 다른 작업이 실행되는데요. 만약 이 값이 false면 SqlType을 찾아오기 위해서 getParameterMetaData()를 호출합니다. getParameterMetaData()는 사용하는 데이터베이스의 드라이버 구현체에 정의된 함수로, PreparedStatemenet에 설정된 파라미터의 타입 정보(ParameterType)를 가져오는 역할을 하죠.\nprivate static void setNull(PreparedStatement ps, int paramIndex, int sqlType, @Nullable String typeName)\n  throws SQLException {\n    if (sqlType == SqlTypeValue.TYPE_UNKNOWN || (sqlType == Types.OTHER && typeName == null)) {\n      boolean useSetObject = false;\n      Integer sqlTypeToUse = null;\n      if (!shouldIgnoreGetParameterType) {\n        try {\n          sqlTypeToUse = ps.getParameterMetaData().getParameterType(paramIndex);\n        }\n        catch (SQLException ex) {\n          if (logger.isDebugEnabled()) {\n            logger.debug(\"JDBC getParameterType call failed - using fallback method instead: \" + ex);\n          }\n        }\n      }\n    //...\n}\ngetParameterMetadata 함수가 SQLException을 내려줄 수 있는 것을 보니, 실제로 데이터베이스와 직접 커넥션을 맺어 쿼리 한다는 것을 유추할 수 있어요.\n저는 Oracle에 있는 테이블에 데이터를 insert하고 있는 상황이었기 때문에 JDBC 내에서는 OracleParameterMetaData 라는 구현 객체를 사용하고 있었는데요. 이 클래스의 구현을 보니, 실제 해당 PreparedStatement에 대한 메타데이터를 조회하는 쿼리를 직접 생성해서 요청을 데이터베이스에 보내고 있습니다.\n// OracleParameterMetaData.class\nstatic final ParameterMetaData getParameterMetaData(OracleSql var0, Connection var1, OraclePreparedStatement var2) throws SQLException {\n  OracleParameterMetaData var3 = null;\n  String var4 = var0.getSql(true, true);\n  int var5 = var0.getParameterCount();\n  OracleParameterMetaDataParser var6 = null;\n  String var7 = null;\n  if (!var0.sqlKind.isPlsqlOrCall() && var0.getReturnParameterCount() < 1 && var5 > 0 && !BAD_SQL.contains(var4.hashCode())) {\n    var6 = new OracleParameterMetaDataParser();\n    var6.initialize(var4, var0.sqlKind, var5);\n            \n    try {\n      var7 = var6.getParameterMetaDataSql(); // metadata를 가져오기 위한 sql 생성\n    } catch (Exception var14) {\n      var7 = null;\n    }\n  }\n\n    if (var7 == null) {\n      var3 = new OracleParameterMetaData(var5);\n    } else {\n      PreparedStatement var8 = null;\n\n      try {\n        var8 = var1.prepareStatement(var7); // 쿼리 실행\n        ResultSetMetaData var9 = var8.getMetaData();\n\t\t\t}\n    // ...\n// ...\n해결하기: 파라미터 타입 명시\n위 내용을 바탕으로 해결 방법은 2가지로 추려질 수 있었는데요.\nshouldIgnoreGetParameterType의 설정 변경하기\n첫 번째 방법은 shouldIgnoreGetParameterType 설정을 변경하는 거예요. getParameterType을 무시하는 설정을 하면 타입을 지정하기 위해 추가 쿼리를 실행하는 대신, Spring JDBC가 내부적으로 null 값을 어떻게 설정할지 결정할 수 있어요. 이는 데이터베이스 벤더에 따라 다르게 처리되거나, 처리가 불가능하면 각 데이터베이스 드라이버의 구현체로 이 문제를 위임합니다. 이 설정은 Spring 내에서 spring.jdbc.getParameterType.ignore를 true로 설정해서 적용할 수 있어요.\n파라미터를 넘길 때 타입 명시하기\n두 번째 방법은 파라미터를 전달할 때 파라미터의 SqlType을 명시하는 방법이에요. 값이 null이어도 해당 파라미터에 대한 SQL 타입을 명확히 알고 있다면, setNull()이 메타데이터를 조회하기 위해 쿼리를 실행하지 않을 수 있어요.\n저는 이 두 가지 방법 중에서 두 번째 방법을 선택했어요. 먼저 전체 시스템에 영향을 줄 수 있는 Spring 설정을 바꾸는 것이 좋은 방법 같지 않았어요. 그리고 특정 값이 null로 설정될 수 있는 경우가 제한적이고 예외적이라고 판단해서 타입 명시로 충분하다고 생각했습니다. 그래서 다음과 같이 직접 해당 파라미터의 SqlType을 선언하는 방식으로 문제를 해결했어요. \nreturn MapSqlParameterSource()\n  .addValue(\"originId\", internalOriginId)\n  .addValue(\"authDate\", authDate)\n  .addValue(\"cancelDate\", cancelDate, Types.NULL)\n...\n이렇게 파라미터 타입을 명시하는 개선 작업을 한 뒤, 100만 건 내외의 거래 데이터를 insert 하는 데 18분 소요되던 배치가 2분으로 줄어들었습니다.\n\n다른 데이터베이스에서는 문제가 없을까?\n앞서 살펴본 것처럼 Oracle은 타입이 null로 설정될 때마다 메타데이터를 조회해주는 쿼리를 실행하는 것을 알 수 있는데요. 다른 데이터베이스에도 비슷한 문제가 발생할지 궁금했어요. 그래서 MySQL의 드라이버인 mysql-connector에서 PreparedStatement의 구현을 살펴봤습니다. MySQL은 parameterMetaData를 한 번 초기화한 후에는 이 객체를 계속 재사용해서 결과를 제공하고 있었습니다. 즉, 같은 PreparedStatement를 사용한다면, 이미 가져온 parameterMetaData를 재사용해서 결과를 제공하는 것이죠.\n// ClientPreparedStatement.java\n@Override\n  public ParameterMetaData getParameterMetaData() throws SQLException {\n    synchronized (checkClosed().getConnectionMutex()) {\n      if (this.parameterMetaData == null) {\n        if (this.session.getPropertySet().getBooleanProperty(PropertyKey.generateSimpleParameterMetadata).getValue()) {\n          this.parameterMetaData = new MysqlParameterMetadata(((PreparedQuery) this.query).getParameterCount());\n        } else {\n          this.parameterMetaData = new MysqlParameterMetadata(this.session, null, ((PreparedQuery) this.query).getParameterCount(),\n          this.exceptionInterceptor);\n        }\n      }\n      return this.parameterMetaData; // 한번 가져온 parameterMetaData를 재사용\n    }\n  }\nOracle과 MySQL의 드라이버 구현체 차이가 여기서 확연히 드러나는 것을 확인할 수 있었는데요. MySQL은 ParameterMetaData라는 객체를 PreparedStatement 내부에서 직접 관리하고 있어서 같은 Statement에 대한 메타데이터를 재사용할 수 있는 구조였어요. 반면 Oracle 구현체는 PreparedStatement와 ParameterMetadata 객체 간의 직접적인 연관 없이 별개의 객체로 구성되어 있고, 필요할 때마다 sqlObject를 넘겨 쿼리에 대한 메타데이터를 가지고 오고 있었어요.\n이런 구조적 차이가 있어서 Oracle에서는 하나의 PreparedStatement에 null 값을 가진 요청이 있을 때마다 매번 ParameterMetaData 값을 조회하기 위해 관련 함수를 호출했던 것이죠. 이 과정이 성능에 영향을 미쳤고요.\n// OraclePreparedStatement.class\npublic ParameterMetaData getParameterMetaData() throws SQLException {\n  this.connection.beginNonRequestCalls();\n\n  ParameterMetaData var1;\n  try {\n    this.ensureOpen();\n    // PreparedStatement와 별도로 ParameterMetaData를 관리\n    var1 = OracleParameterMetaData.getParameterMetaData(this.sqlObject, this.connection, this);\n  } finally {\n    this.connection.endNonRequestCalls();\n  }\n  return var1;\n}\n이번 성능 저하 현상을 해결하면서 저에게 두 가지 중요한 경험이 남았는데요. 첫 번째는 성능 이슈를 진단하기 위해 네트워크 패킷을 직접 분석하는 새로운 접근 방식을 시도한 거예요. 이 방법은 단순히 로그 분석만으로는 알 수 없었던, 문제의 근본 원인이 되는 부분을 파악하는 데 매우 효과적이었어요. 두 번째는 Spring JDBC와 각각의 데이터베이스 드라이버 구현체가 어떻게 상호 작용하고 실행되는지에 대한 깊이 있는 이해를 얻었다는 것이고요. \n처음에는 이해하기 어려웠던 성능 문제를 깊이 파악하고 해결해 볼 수 있어 의미 있는 시간이었습니다. 이런 문제 해결에 관심이 있는 분이라면 토스페이먼츠 서버 챕터에 합류해서 함께 도전해 봐요!\n\nWrite 강민주 Review 황진성, 박동호 Edit 한주연\n",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "Server"
        },
        {
          "content": "Spring"
        }
      ]
    }
  },
  {
    "key": "restructuring-planning",
    "title": "달리는 기차의 바퀴 교체하기 1. Planning",
    "subtitle": "이미 운영 중인 제품을 전부 갈아엎고 다시 만드는 경험을 하기는 어려운데요. 운 좋게 팀 내 공감대가 형성되어 여러 팀원과 하나의 제품을 온전히 개선해 볼 수 있었어요. 이 글에서는 구체적인 개선 내용에 앞서 어떻게 프로젝트를 셋업하고 진행했는지 소개할게요.",
    "publishedTime": "2024-01-11T15:10:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/payments-train-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/payments-train-thumb.jpg"
    },
    "editor": {
      "name": "한재엽",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "이미 운영 중인 제품을 전반적으로 다시 만들거나 리팩토링 하는 경험을 해볼 수 있는 기회는 흔치 않은데요. 운 좋게 팀 내 공감대가 형성되어 여러 팀원과 하나의 제품을 온전히 개선해 볼 수 있었어요. 이 글에서는 구조 개선에 앞서 어떻게 프로젝트를 플래닝하고 진행했는지 소개할게요.\n브랜드페이?\n토스페이먼츠의 결제 제품 중",
    "fullDescription": "이미 운영 중인 제품을 전반적으로 다시 만들거나 리팩토링 하는 경험을 해볼 수 있는 기회는 흔치 않은데요. 운 좋게 팀 내 공감대가 형성되어 여러 팀원과 하나의 제품을 온전히 개선해 볼 수 있었어요. 이 글에서는 구조 개선에 앞서 어떻게 프로젝트를 플래닝하고 진행했는지 소개할게요.\n브랜드페이?\n토스페이먼츠의 결제 제품 중",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "리팩토링"
        }
      ]
    }
  },
  {
    "key": "engineering-note-6",
    "title": "브라우저용 번들링 플러그인, 직접 만들었어요",
    "subtitle": "프론트엔드 번들링 도구를 사용하는 것을 넘어 직접 플러그인을 만들어 본 과정을 소개해요.",
    "publishedTime": "2024-01-10T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/gathering-code-thumb-4.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/gathering-code-thumb-4.jpg"
    },
    "editor": {
      "name": "신지호",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "엔지니어링 노트 6: 브라우저용 번들링 플러그인, 직접 만들었어요\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 직접 브라우저용 프론트엔드 번들링 플러그인을 만든 과정에 대한 이야기예요.\n지난해 말, 토스페이먼츠 DX(Developer eXper",
    "fullDescription": "엔지니어링 노트 6: 브라우저용 번들링 플러그인, 직접 만들었어요\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 직접 브라우저용 프론트엔드 번들링 플러그인을 만든 과정에 대한 이야기예요.\n지난해 말, 토스페이먼츠 DX(Developer eXper",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "engineering-note-5",
    "title": "프론트엔드 로깅 신경 안 쓰기",
    "subtitle": "프론트엔드 개발자라면 한 번쯤 고민해봤을 클라이언트 로깅 개선 과정을 공유합니다.",
    "publishedTime": "2023-12-20T10:45:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/payments-frontend-thumb-2.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/payments-frontend-thumb-2.jpg"
    },
    "editor": {
      "name": "최진영",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "엔지니어링 노트 5: 프론트엔드 로깅 신경 안 쓰기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 프론트엔드 개발자라면 한 번쯤 고민해봤을 클라이언트 로깅 개선 과정을 공유합니다.\n제품을 개발하다 보면 사용자가 어떻게 제품을 사용하는지, 제품을 ",
    "fullDescription": "엔지니어링 노트 5: 프론트엔드 로깅 신경 안 쓰기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 프론트엔드 개발자라면 한 번쯤 고민해봤을 클라이언트 로깅 개선 과정을 공유합니다.\n제품을 개발하다 보면 사용자가 어떻게 제품을 사용하는지, 제품을 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "reactor-netty-memory-leak",
    "title": "Reactor Netty Memory Leak 이슈 탐방기",
    "subtitle": "Spring Cloud Gateway와 Spring WebClient를 이용하면서 발생한 Memory Leak 이슈의 발생 원인과 해결 과정을 소개합니다.",
    "publishedTime": "2023-12-11T16:32:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/3d/toss-tech-reactor-center.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/3d/toss-tech-reactor-center.png"
    },
    "editor": {
      "name": "김성현",
      "shortDescription": "토스 Server Developer"
    },
    "shortDescription": "토스의 백엔드로 오는 요청은 모두 Spring Cloud Gateway 기반의 API Gateway를 통해 클러스터로 들어와요. 그리고 클러스터 안에서는 수많은 서버들이 Spring WebClient를 통한 REST API로 통신해 요청을 처리해요.\n최근 두 가지 도구에서 동일한 Memory Leak 이슈를 경험했는데요.",
    "fullDescription": "토스의 백엔드로 오는 요청은 모두 Spring Cloud Gateway 기반의 API Gateway를 통해 클러스터로 들어와요. 그리고 클러스터 안에서는 수많은 서버들이 Spring WebClient를 통한 REST API로 통신해 요청을 처리해요.\n최근 두 가지 도구에서 동일한 Memory Leak 이슈를 경험했는데요.",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "engineering-note-4",
    "title": "인자가 많은 메서드는 왜 나쁠까?",
    "subtitle": "인자가 많은 메서드를 함께 리팩토링 하면서 코드 사용자 입장에서 코드 복잡성을 관리하는 방법을 알아봅니다.",
    "publishedTime": "2023-11-29T10:16:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/contents-fx-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/contents-fx-thumb.jpg"
    },
    "editor": {
      "name": "나재은",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "엔지니어링 노트 4: 인자가 많은 메서드는 왜 나쁠까?\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 인자가 많은 메서드를 함께 리팩토링 하면서 코드 사용자 입장에서 코드 복잡성을 관리하는 방법을 알아봅니다.\n이전 글 ‘null은 왜 나쁠까?’의",
    "fullDescription": "엔지니어링 노트 4: 인자가 많은 메서드는 왜 나쁠까?\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 이번에는 인자가 많은 메서드를 함께 리팩토링 하면서 코드 사용자 입장에서 코드 복잡성을 관리하는 방법을 알아봅니다.\n이전 글 ‘null은 왜 나쁠까?’의",
    "seoConfig": {
      "tags": [
        {
          "content": "리팩토링"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "engineering-note-3",
    "title": "Feign 코드 분석과 서버 성능 개선",
    "subtitle": "Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.",
    "publishedTime": "2023-11-22T14:30:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/feign-thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/feign-thumb.jpg"
    },
    "editor": {
      "name": "김성두",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "엔지니어링 노트 3: Feign 코드 분석과 서버 성능 개선\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.\n얼마 전 토스페이먼츠 서버 모니터링 시스템을 ",
    "fullDescription": "엔지니어링 노트 3: Feign 코드 분석과 서버 성능 개선\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. Feign과 다중 스레드를 사용하는 과정에서 생긴 문제를 이해하고 성능 개선까지 한 경험을 공유해요.\n얼마 전 토스페이먼츠 서버 모니터링 시스템을 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "Feign"
        }
      ]
    }
  },
  {
    "key": "engineering-note-2",
    "title": "null 리턴은 왜 나쁠까?",
    "subtitle": "코드 복잡성 관리 측면에서 의미를 축약한 표현의 문제와 해결 방법을 예제로 알아봐요.",
    "publishedTime": "2023-11-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/ml-illust/_20231108_104549157.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/ml-illust/programmer-handling-code-box-with-highlighting-lines_20231106_111448975.png"
    },
    "editor": {
      "name": "나재은",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "엔지니어링 노트 2: 코드 복잡성 관리하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 두 번째로 코드 복잡성을 관리하는 방법을 소개합니다.\n\n개발자의 고객은 누구라고 생각하시나요? 우리 제품을 사용하는 사용자(End-user)죠. 그런데 또 다른 고객",
    "fullDescription": "엔지니어링 노트 2: 코드 복잡성 관리하기\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 두 번째로 코드 복잡성을 관리하는 방법을 소개합니다.\n\n개발자의 고객은 누구라고 생각하시나요? 우리 제품을 사용하는 사용자(End-user)죠. 그런데 또 다른 고객",
    "seoConfig": {
      "tags": [
        {
          "content": "리팩토링"
        },
        {
          "content": "문화"
        }
      ]
    }
  },
  {
    "key": "engineering-note-1",
    "title": "웹에서 복잡한 퍼널 쉽게 관리하기",
    "subtitle": "토스페이먼츠 프론트엔드 챕터에서 웹에서 퍼널을 손쉽게 관리하기 위해 했던 고민과 해결 방법을 공유해요.",
    "publishedTime": "2023-10-18T09:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/engineering_thumb.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/payments/contents/engineering_thumb.jpg"
    },
    "editor": {
      "name": "임재후/최수민",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "엔지니어링 노트 1: 복잡한 퍼널 쉽게 관리하기\n\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 첫 번째는 프론트엔드 이야기인데요. 웹에서 퍼널을 손쉽게 관리할 수 있도록 만든 모듈을 소개합니다.\n토스 제품 디자인 원칙(PP: Product Princip",
    "fullDescription": "엔지니어링 노트 1: 복잡한 퍼널 쉽게 관리하기\n\n엔지니어링 노트 시리즈는 토스페이먼츠 개발자들이 제품을 개발하면서 겪은 기술적 문제와 해결 방법을 직접 다룹니다. 첫 번째는 프론트엔드 이야기인데요. 웹에서 퍼널을 손쉽게 관리할 수 있도록 만든 모듈을 소개합니다.\n토스 제품 디자인 원칙(PP: Product Princip",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "slash23-devops",
    "title": "유연하고 안전하게 배포 Pipeline 운영하기",
    "subtitle": "생산성, 안정성, 보안성을 모두 달성하기 위해선 ‘Pipeline’을 어떻게 설정해야 할까요?\n다양하고 복잡한 토스뱅크의 배포 ‘Pipeline’를 안전하게 운영하기 위한 노력을 소개합니다.",
    "publishedTime": "2023-10-12T20:30:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_06_김동석.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_06_김동석.png"
    },
    "editor": {
      "name": "김동석",
      "shortDescription": "토스뱅크 DevOps Engineer"
    },
    "shortDescription": "토스뱅크에는 400개가 넘는 배포 Pipeline 이 있습니다. Pipeline의 개수가 많아지고, 종류가 다양해지고, 동작이 복잡해지며 여러 어려움이 생기는데요. 토스뱅크에서 Pipeline을 유연하고 안전하게 운영하기 위해 노력한 이야기를 소개해 보려 합니다.\nPipeline이란?\n반복하는 일을 자동화하는 시스템을 말",
    "fullDescription": "토스뱅크에는 400개가 넘는 배포 Pipeline 이 있습니다. Pipeline의 개수가 많아지고, 종류가 다양해지고, 동작이 복잡해지며 여러 어려움이 생기는데요. 토스뱅크에서 Pipeline을 유연하고 안전하게 운영하기 위해 노력한 이야기를 소개해 보려 합니다.\nPipeline이란?\n반복하는 일을 자동화하는 시스템을 말",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH23"
        },
        {
          "content": "Security"
        }
      ]
    }
  },
  {
    "key": "slash23-server",
    "title": "토스는 Gateway 이렇게 씁니다",
    "subtitle": "더 안전하고 안정적인 서비스 운영을 위해서 ‘gateway’를 어떻게 사용해야 할까요? \n토스의 수많은 마이크로서비스 로직을 공통화하기 위한 gateway 운영 방법에 대해 소개합니다.",
    "publishedTime": "2023-10-12T19:52:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_05_최준우.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_05_최준우.png"
    },
    "editor": {
      "name": "최준우",
      "shortDescription": "토스 Server Developer"
    },
    "shortDescription": "안녕하세요. 토스에서 Gateway를 개발하고 있는 서버플랫폼팀 최준우입니다. \n토스에서는 목적에 맞는 다양한 Gateway를 사용하고 있는데요. 저는 이번 글에서 이러한 Gateway 아키텍처를 통해 토스가 누리고 있는 장점들과 이를 위해 어떠한 노력을 하고 있는지에 대해 간단히 소개하려고 합니다.\nGateway 란?\n",
    "fullDescription": "안녕하세요. 토스에서 Gateway를 개발하고 있는 서버플랫폼팀 최준우입니다. \n토스에서는 목적에 맞는 다양한 Gateway를 사용하고 있는데요. 저는 이번 글에서 이러한 Gateway 아키텍처를 통해 토스가 누리고 있는 장점들과 이를 위해 어떠한 노력을 하고 있는지에 대해 간단히 소개하려고 합니다.\nGateway 란?\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "slash23-data",
    "title": "대규모 로그 처리도 OK! Elasticsearch 클러스터 개선기",
    "subtitle": "일평균 56억 건 이상 수집되는 토스증권의 로그, 어떻게 효율적으로 처리할까요?\n큰 폭으로 늘어나는 대규모 로그 처리를 위한 ‘Elasticsearch 클러스터 개선 경험’을 소개합니다.",
    "publishedTime": "2023-10-12T16:03:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_04_%EC%9D%B4%EC%A4%80%ED%99%98.png"
    },
    "editor": {
      "name": "이준환",
      "shortDescription": "토스증권 Data Engineer"
    },
    "shortDescription": "로그 수집 현황\n토스증권이 운영하는 서비스와 인프라에서는 매일 수많은 로그들이 생성되고 있고, 이를 Elasticsearch 클러스터로 수집하여 로그를 검색하고 분석하고 있습니다. 이러한 로그들은 약 100여 개의 로그 파이프라인을 통해 하루 기준으로 22테라 바이트, 약 170억 건의 로그를 인덱싱하고 있는데요, 서비스",
    "fullDescription": "로그 수집 현황\n토스증권이 운영하는 서비스와 인프라에서는 매일 수많은 로그들이 생성되고 있고, 이를 Elasticsearch 클러스터로 수집하여 로그를 검색하고 분석하고 있습니다. 이러한 로그들은 약 100여 개의 로그 파이프라인을 통해 하루 기준으로 22테라 바이트, 약 170억 건의 로그를 인덱싱하고 있는데요, 서비스",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Data"
        },
        {
          "content": "Elasticsearch"
        }
      ]
    }
  },
  {
    "key": "frontend-diving-club-agora",
    "title": "프론트엔드 다이빙클럽에서 만나는 아고라: 다른 회사에선 테스트 코드 어떻게 짜요?",
    "subtitle": "‘프론트엔드 테스팅’을 주제로 진행된 프론트엔드 다이빙 클럽의 네번째 모임을 공유합니다.",
    "publishedTime": "2023-10-11T11:39:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/ml-illust/img-people-check-outfut.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/ml-illust/img-people-check-outfut.jpg"
    },
    "editor": {
      "name": "서현석",
      "shortDescription": "토스증권 Frontend Developer"
    },
    "shortDescription": "안녕하세요. 토스증권 프론트엔드 개발자 서현석입니다.\n여러분은 ‘아고라(agora)’라는 단어를 들으면 어떤 뜻이 가장 먼저 떠오르시나요? 어원으로 거슬러 올라가면 그리스 도시국가(폴리스)에서 시민들이 자유롭게 토론을 벌이던 장소이자 고대 그리스어로는 ἀγορά, 즉 열린 공간, 광장을 뜻합니다. 아고라에서는 그리스의 정",
    "fullDescription": "안녕하세요. 토스증권 프론트엔드 개발자 서현석입니다.\n여러분은 ‘아고라(agora)’라는 단어를 들으면 어떤 뜻이 가장 먼저 떠오르시나요? 어원으로 거슬러 올라가면 그리스 도시국가(폴리스)에서 시민들이 자유롭게 토론을 벌이던 장소이자 고대 그리스어로는 ἀγορά, 즉 열린 공간, 광장을 뜻합니다. 아고라에서는 그리스의 정",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "테스트"
        }
      ]
    }
  },
  {
    "key": "isomorphic-javascript",
    "title": "환경 고민없이 개발하기",
    "subtitle": "서버 사이드 렌더링 작동 방식과 Isomorphic에 대해 소개드려요.",
    "publishedTime": "2023-09-01T12:10:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-how-to-read.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-common/230823_techblog_thumb_nail.png"
    },
    "editor": {
      "name": "김동현",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "토스 프론트엔드 챕터는 유저가 경험하는 로딩 시간을 줄이기 위해 지속적으로 노력하고 있습니다. 특히 Slash 22를 통해 서버 사이드 렌더링(SSR)를 이용한 개선 사례를 소개드린 적이 있는데요. 이번 아티클에서는 Next.js 도입 과정에서 마주한 문제와 해결 방법을 소개할게요.\n서버 사이드 렌더링 \n서버 사이드 렌더",
    "fullDescription": "토스 프론트엔드 챕터는 유저가 경험하는 로딩 시간을 줄이기 위해 지속적으로 노력하고 있습니다. 특히 Slash 22를 통해 서버 사이드 렌더링(SSR)를 이용한 개선 사례를 소개드린 적이 있는데요. 이번 아티클에서는 Next.js 도입 과정에서 마주한 문제와 해결 방법을 소개할게요.\n서버 사이드 렌더링 \n서버 사이드 렌더링(SSR)은 렌더링 작업 일부를 서버에 위임하는 방식이에요. 브라우저에게 완성된 HTML을 전달하는 것이죠. 사용자는 빠르게 서비스를 이용할 수 있고, 서비스는 검색 엔진 최적화(SEO)로 더 많은 노출 기회를 얻을 수 있습니다.\n하지만 서버 사이드 렌더링(SSR)을 위해서는 별도의 서버를 운영해야 돼요.  프레임워크를 사용하는 경우, 서버 구축 및 운영 등의 문제에는 벗어날 수 있지만 렌더링 과정에 서버가 개입되면서 window is not defined 와 같은 생소한 에러를 경험하게 됩니다.\n단순하게 생각해보면 서버에서 제공한 HTML을 이용한 것뿐인데, 왜 이런 에러를 경험하게 되는걸까요? 서버 사이드 렌더링(SSR)환경에서 흔히 발생하는 에러와 그 해결법을 사례를 통해 살펴볼게요.\nNext.js 렌더링 과정\n예시로 살펴볼 애플리케이션은 쿼리 파라미터로 전달받은 유저의 이름을 화면에 출력해요.\nfunction App() {\n\t// 쿼리 파라미터로 전달받은 유저의 이름을 얻어온다.\n\tconst name = new URL(location.href).searchParams.get(name);\t\n\t// 유저의 이름을 화면에 출력한다.\n\treturn <div>{name}</div>\n}\n코드를 살펴보면 문제없이 동작할 것 같지만 서버 사이드 렌더링(SSR) 환경에서 에러가 발생하는데요. 어떤 부분이 에러를 일으키는걸까요? 에러 메시지를 보며, 원인을 찾아보겠습니다.\n\n1. 서버가 HTML을 생성한다.\n\n메세지를 살펴보면, 에러가 발생한 환경은 다음과 같은 특징을 가지고 있습니다.\n브라우저 객체인 location 이 존재하지 않는다. (location is not defined)\n페이지(HTML) 생성이 가능하다. (This error happened while generating the page)\nlocation은 브라우저 환경에서 제공되는 객체로, URL 관련 속성 및 메소드를 제공합니다.\n즉  1) 브라우저가 아니면서 동시에 2) 페이지(HTML) 생성이 가능하다는 특징으로 해당 에러는 서버에서 발생한 에러임을 추측할 수 있어요.\n서버는 클라이언트에서 제공한 컴포넌트를 기반으로 HTML을 생성하는데요. 이때 만약 클라이언트 환경에만 존재하는 코드가 있다면 어떤 일이 일어날까요? 서버는 해당 코드의 작동 방식을 이해할 수 없고, 이로 인해 에러가 발생해요.\n처음 작성한 코드를 다시 돌아가보면 location 은 클라이언트 환경에만 존재하는 브라우저 객체입니다. 따라서, 해당 에러를 해결하기 위해서는 서버 환경에서 location 에 접근할 수 없도록 수정해야 돼요.\nfunction App() {\n\tconst name = (() => {\n\t\t/* 서버 환경인 경우, 객체에 접근하지 못하도록 수정 .. */\n\t\tif ( isServer() ) {\n\t\t\treturn null;\n\t\t}\n\t\t return new URL(location.href).searchParams.get(name);\t\n\t})();\n\t/* 유저의 이름을 화면에 출력한다 ..*/\n\treturn <div>{name}</div>\n}\n\n2. Hydration Mismatch\n서버 환경에서 브라우저 객체에 접근할 수 없도록 수정한 후, 새로운 에러가 발생했어요.\n\n위 에러를 해결하려면 Hydration 을 이해해야 돼요.\n서버에서는 사용자 인터랙션이 불가능한 단순 마크업 HTML을 생성해요. 따라서 React는 이벤트 리스너, 상태 관리와 같은 클라이언트 로직을 서버로부터 전달받은 HTML과 통합하여 애플리케이션으로 작동할 수 있도록 합니다. 이 통합 과정이 Hydration 입니다.\n여기서 로직 연결 과정을 주의깊게 봐야 돼요. React는 요소(Element)와 로직 정보가 담긴 가상 DOM을 생성한 뒤, 이를 전달받은 HTML과 비교해요. 그래서 서버와 클라이언트의 렌더링 결과가 같을 때만 Hydration 을 할 수 있어요.\n그럼 코드의 문제가 뭘까요? 서버에서 바라보는 name 변수의 값은 항상  null  인데요. 클라이언트는 쿼리파라미터에 따라 사용자 이름을 출력하고 있어요. 따라서 쿼리 파라미터가 있으면, 서버와 클라이언트는 각각 다른 결과를 렌더링하고 Hydration 을 할 수 없는 상태인 것이죠.\n// 서버\n<div>{null}</div>\n\n// 클라이언트\n<div>{'김토스'}</div>\n하나의 코드, 동일한 결과 Isomorphic \n그렇다면 어떻게 문제를 해결할 수 있을까요? \nHydration Mismatch를 해결하기 위해서는, 서버와 클라이언트의 렌더링 결과물이 같아야 합니다. 이를 위해 서버 환경에서 쿼리 파라미터에 접근할 수 있는 별도의 로직을 작성해야 돼요. \nfunction App() {\n\tconst name = (() => {\n\t\tif (isServer()) {\n\t    /* 서버 환경에서 쿼리 파라미터 접근 및 반환하는 별도 로직... */\n\t\t}\n\t\t return new URL(location.href).searchParams.get(name);\t\n\t});\n\treturn <div>{name}</div>\n}\n다행히도 Next.js는 개발자가 겪을 불편함을 줄여주고자 useRouter() 을 제공하고 있어요.\nimport { useRouter } from 'next/router';\n\nfunction App() {\n\tconst name = useRouter().query.name;\n\n\treturn <div>{name}</div>\n}\nuseRouter() 를 사용하면 별도의 예외처리 없이도 서버, 클라이언트 어떤 환경에서든 동일한 결과 값을 보장 받을 수 있어요.\n// 서버\n<div>{'김토스'}</div>\n\n// 클라이언트\n<div>{'김토스'}</div>\n이처럼 서버와 클라이언트 양측에 동일한 결과를 보장하는 코드를 isomorphic 하다고 표현해요. \n요구사항을 다시 살펴보면, 쿼리 파라미터 값을 화면에 출력하는 매우 간단한 작업인데요. 서버 사이드 렌더링 환경을 이해하지 않았다면 에러를 해결하는 데 많은 시간을 소비했을 것입니다. 만약 처음부터 useRouter()를 사용했다면 어땠을까요? \nisomorphic 한 코드는 나와 동료의 시간을 절약해요. 일관된 결과를 서버와 클라이언트 양측에 보장하기 위해서는 관련 작업이 반드시 필요해요. 따라서, 이러한 작업들을 추상화해둔다면 불필요한 코드들을 감춰지고, 구현에만 집중할 수 있게 됩니다.\n\n토스의 isomorphic\n그렇다면 실제 서비스에 적용해볼 수 있는 실용적인 사례는 없을까요? 토스 프론트엔드 챕터에서 사용하고 있는 isomorphic 사례를 소개하면서 글을 마무리할게요.\nSSRSuspense\n<Suspense /> 는 비동기 요청을 선언적으로 처리할 수 있도록 돕는 컴포넌트인데요.\nPromise가 대기 상태일 때(Pending) : <Loading />\nPromise가 완료됐을 때(Resolved): <APIRequestComponent />\nfunction App() {\n\treturn (\n\t\t<Suspense fallback={<Loading/>}>\n\t\t\t<APIRequestComponent />\n\t\t</Suspense>\n\t)\n}\n그러나 React 18 버전 미만에서는 <Suspense/>가 오직 클라이언트 환경에서만 정상 작동한다는 한계점이 있어요. SSR 환경에서 안정적으로 작동할 수 있도록 <Suspense/>는 컴포넌트가 마운트 되기 전에는 fallback 컴포넌트를 렌더링합니다.\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "slash23-security",
    "title": "금융사 최초의 Zero Trust 아키텍처 도입기",
    "subtitle": "왜 보안이 강화될수록, 업무는 불편해지는 걸까요? \n금융에서 가장 중요한 가치인 ‘안전’과 혁신을 위한 ‘업무 편의성’, 두 마리 토끼를 모두 잡기 위한 여정을 소개합니다.  ",
    "publishedTime": "2023-09-01T11:59:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_03%20(1).png"
    },
    "editor": {
      "name": "정연우",
      "shortDescription": "토스 Security Engineer"
    },
    "shortDescription": "전통적인 환경의 보안 아키텍처는 방화벽과 같은 경계를 기준으로 신뢰와 비신뢰를 나누어서 운영이 되고 있었는데요. 신뢰 구간에서의 추가적인 보안 통제가 없으면서 신뢰의 크기가 커진다면 그만큼 보안의 Risk들도 증가하게 된다는 한계점들이 있었고, 다원화 된 Identity 관리, 보안 솔루션 관리, 재택근무 환경과 오피스 ",
    "fullDescription": "전통적인 환경의 보안 아키텍처는 방화벽과 같은 경계를 기준으로 신뢰와 비신뢰를 나누어서 운영이 되고 있었는데요. 신뢰 구간에서의 추가적인 보안 통제가 없으면서 신뢰의 크기가 커진다면 그만큼 보안의 Risk들도 증가하게 된다는 한계점들이 있었고, 다원화 된 Identity 관리, 보안 솔루션 관리, 재택근무 환경과 오피스 ",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "SLASH23"
        },
        {
          "content": "Security"
        }
      ]
    }
  },
  {
    "key": "slash23-corebanking",
    "title": "은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)",
    "subtitle": "수십 년간 정체되어 있던 전통적인 은행 시스템의 모놀리식 소프트웨어 아키텍처를 MSA로 전환할 수 있을까요? \n토스뱅크의 ‘코어뱅킹 MSA 전환’ 사례를 통해 향후 은행 시스템이 나아가야 할 방향을 소개합니다.",
    "publishedTime": "2023-08-31T23:37:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_02.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/techblog_slash23_thumb_02.png"
    },
    "editor": {
      "name": "장세경/조서희",
      "shortDescription": "토스뱅크 Server Developer"
    },
    "shortDescription": "토스뱅크는 기존의 공급자 중심의 뱅킹 서비스를 고객 중심으로 변화시키기 위해 많은 노력을 기울이고 있어요.\n그러나 기존의 전통적인 뱅킹 시스템을 구현하는 방식으로는 안정적인 고객 중심 뱅킹 서비스 제공에 여러 기술적 한계가 있었죠. \n이번 아티클에서는 토스뱅크가 어떤 방식으로 기술적 한계를 극복했고, 어떤 기술로 고객 중",
    "fullDescription": "토스뱅크는 기존의 공급자 중심의 뱅킹 서비스를 고객 중심으로 변화시키기 위해 많은 노력을 기울이고 있어요.\n그러나 기존의 전통적인 뱅킹 시스템을 구현하는 방식으로는 안정적인 고객 중심 뱅킹 서비스 제공에 여러 기술적 한계가 있었죠. \n이번 아티클에서는 토스뱅크가 어떤 방식으로 기술적 한계를 극복했고, 어떤 기술로 고객 중",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        },
        {
          "content": "MSA"
        }
      ]
    }
  },
  {
    "key": "slash23-iOS",
    "title": "레고처럼 조립하는 토스 앱",
    "subtitle": "수많은 서비스를 담고 있는 대규모 iOS 앱에 어울리는 아키텍처는 무엇일까요?\n프로젝트 간의 의존성과 모듈 간의 결합도를 낮춰, 더 효율적인 서비스 개발, 관리를 이뤄낸 과정을 소개합니다. ",
    "publishedTime": "2023-08-22T17:46:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/toss-tech/slash_juneseokbeomgun_thumb.png"
    },
    "editor": {
      "name": "이준석/송범근",
      "shortDescription": "토스 iOS Developer"
    },
    "shortDescription": "\n100만 줄.\n이게 뭐냐고요?\n바로, 토스 iOS 앱의 코드량입니다.\n\n토스팀은 사용자에게 가치를 전달하기 위해 끊임없이 서비스를 개발해왔어요. 지금 토스 앱 안에는 수백 개의 서비스가 들어있습니다. 그렇게 성장해오는 동안, 토스 iOS 앱도 Swift 100만 줄이 넘는 거대한 프로젝트로 자라났습니다.\n\n이 글을 읽고",
    "fullDescription": "\n100만 줄.\n이게 뭐냐고요?\n바로, 토스 iOS 앱의 코드량입니다.\n\n토스팀은 사용자에게 가치를 전달하기 위해 끊임없이 서비스를 개발해왔어요. 지금 토스 앱 안에는 수백 개의 서비스가 들어있습니다. 그렇게 성장해오는 동안, 토스 iOS 앱도 Swift 100만 줄이 넘는 거대한 프로젝트로 자라났습니다.\n\n이 글을 읽고",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "SLASH23"
        },
        {
          "content": "iOS"
        }
      ]
    }
  },
  {
    "key": "frontend-diving-club",
    "title": "놀러오세요! 프론트엔드 다이빙 클럽",
    "subtitle": "프론트엔드에 관한 깊은 이야기를 나눌 수 있는 오프라인 커뮤니티, 프론트엔드 다이빙 클럽을 소개합니다.",
    "publishedTime": "2023-07-21T13:47:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/toss-tech/frontend-diving-club.jpg"
    },
    "editor": {
      "name": "진유림",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "안녕하세요, 토스 프론트엔드 개발자 진유림입니다. \n저는 개발을 처음 배울 때부터 커뮤니티 안에서 성장해왔는데요. 9XD, GDG, Facebook Developer Circle등 다양한 온/오프라인 커뮤니티에서 각양각색의 개발자를 만나며 IT업계에 대한 애정을 키우고, 지식은 나눌수록 커진다는 것을 깨달았어요.\n그러나 ",
    "fullDescription": "안녕하세요, 토스 프론트엔드 개발자 진유림입니다. \n저는 개발을 처음 배울 때부터 커뮤니티 안에서 성장해왔는데요. 9XD, GDG, Facebook Developer Circle등 다양한 온/오프라인 커뮤니티에서 각양각색의 개발자를 만나며 IT업계에 대한 애정을 키우고, 지식은 나눌수록 커진다는 것을 깨달았어요.\n그러나 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "27058",
    "title": "AI와 함께 가짜 신분증 찾아내기",
    "subtitle": "비대면 서비스의 편리함을 악용하는 금융 범죄, 더 똑똑하게 대처하는 법은 없을까요? 가짜 신분증을 활용한 이상 거래 탐지 및 예방을 위해 개발한 ‘이미지 학습 솔루션’을 소개합니다.",
    "publishedTime": "2023-06-08T14:57:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_11_%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A2_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김연재",
      "shortDescription": "토스뱅크 Server Developer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "AI"
        },
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "27056",
    "title": "프로파일러로 시스템 성능 향상시키기",
    "subtitle": "서비스 운영 과정 속 여러 장애들, 어떻게 그 원인을 빠르고 정확하게 파악할 수 있을까요? 상황에 맞는 다양한 ‘프로파일러’로 문제 원인을 파악하고 또 해결한 과정을 소개합니다.",
    "publishedTime": "2023-06-08T14:52:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_17_%E1%84%8B%E1%85%B5%E1%84%92%E1%85%A1%E1%86%BC%E1%84%85%E1%85%A7%E1%86%BC_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이항령",
      "shortDescription": "토스 Head of Server"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "27054",
    "title": "은행의 데이터 플랫폼을 오픈소스로 전환하기",
    "subtitle": "토스뱅크는 정보계 시스템을 어떻게 개편하고 있을까요? 오픈 소스를 이용한 플랫폼에서 신뢰할 수 있는 데이터를 운영할 수 있는 방법을 소개합니다.",
    "publishedTime": "2023-06-08T14:50:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_12_%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%B1_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김용휘",
      "shortDescription": "토스뱅크 Data Platform Team Leader"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Data"
        },
        {
          "content": "Open Source"
        }
      ]
    }
  },
  {
    "key": "27052",
    "title": "Kafka 이중화로 다양한 장애 상황 완벽 대처하기",
    "subtitle": "다양한 장애 상황에도 사용자에게 매끄러운 서비스 경험을 제공하는 방법은 뭘까요?더 견고하고 편리한 증권 서비스 구축을 위한 토스증권의 ‘Kafka IDC 이중화’ 과정을 소개합니다.",
    "publishedTime": "2023-06-08T14:48:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_13_%E1%84%80%E1%85%A1%E1%86%BC%E1%84%87%E1%85%A7%E1%86%BC%E1%84%89%E1%85%AE_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "강병수",
      "shortDescription": "토스증권 Data Engineer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Data"
        },
        {
          "content": "Kafka"
        }
      ]
    }
  },
  {
    "key": "27050",
    "title": "Server-driven UI로 다이나믹한 서비스 효율화하기",
    "subtitle": "토스의 얼굴, 홈 화면에서의 매끄러운 사용자 경험은 어디에서 비롯되는 것일까요? 다양한 서비스 운영 효율화를 위한 토스 홈팀의 무기, ‘Server Driven UI’를 소개합니다.",
    "publishedTime": "2023-06-08T14:38:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_14_%E1%84%8B%E1%85%B2%E1%86%AB%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%92%E1%85%A7%E1%86%AB_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "윤중현",
      "shortDescription": "토스 Server Developer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "27048",
    "title": "새로운 은행을 위한 Modern 대외 연계 시스템 구축기",
    "subtitle": "최고의 성과를 위한 최선의 방법을 찾아볼까요? 금융업계에서 일반적으로 사용하는 대외연계 시스템을 처음부터 재구축한 ‘Modern FEP’에 대해 소개합니다. ",
    "publishedTime": "2023-06-08T14:36:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_16_%E1%84%8B%E1%85%B5%E1%84%89%E1%85%A1%E1%86%BC%E1%84%86%E1%85%B5%E1%86%AB_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이상민",
      "shortDescription": "토스뱅크 Server Developer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "27046",
    "title": "보안의 끝없는 Next Level을 향해, 토스의 Security Review",
    "subtitle": "더 완벽한 보안에 도전하는 토스의 여정은 어떨까요? 매일 더 안전해지는 서비스를 만드는 토스의 ‘Security Review’를 소개합니다.",
    "publishedTime": "2023-06-08T14:29:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_18_%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A1%E1%86%AB%E1%84%87%E1%85%A7%E1%86%AF_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "지한별",
      "shortDescription": "토스 Security Researcher"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Security"
        }
      ]
    }
  },
  {
    "key": "27044",
    "title": "토스페이먼츠의 Observability",
    "subtitle": "[수십만 개의 가맹점 * 수백 개의 MSA 서비스 * 복수의 k8s cluster * 수십 개의 원천사]의 조합 복잡도를 가진 토스페이먼츠가 안정적인 서비스 운영을 위해 분산 추적 체계와 로그를 기반으로 구성한 ‘Observability 체계’를 소개합니다. ",
    "publishedTime": "2023-06-08T14:15:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_19_%E1%84%92%E1%85%A1%E1%84%90%E1%85%A2%E1%84%92%E1%85%A9_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "하태호",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "27042",
    "title": "실시간 시세 데이터 안전하고 빠르게 처리하기",
    "subtitle": "토스증권의 시세 정보는 어떤 원리로 보이는 것일까요? 시세 플랫폼을 통해 시스템 구조와 개발 당시 고민했던 과정을 소개합니다.",
    "publishedTime": "2023-06-08T14:13:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_21_%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%83%E1%85%A9%E1%84%8B%E1%85%AF%E1%86%AB_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "정도원",
      "shortDescription": "토스증권 Server Developer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "SLASH23"
        },
        {
          "content": "Server"
        }
      ]
    }
  },
  {
    "key": "27040",
    "title": "Rally로 3분 만에 애니메이션 완성하기",
    "subtitle": "UIKit으로 만들어진 토스 디자인 시스템 SwiftUI에서 쓸 수 있을까?",
    "publishedTime": "2023-06-08T14:05:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_22_%E1%84%8B%E1%85%B5%E1%84%83%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A7%E1%86%AB%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%AE%E1%86%BC_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이동현/최선웅",
      "shortDescription": "토스증권 iOS Developer/Android Developer"
    },
    "shortDescription": "",
    "fullDescription": "",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH23"
        },
        {
          "content": "Interaction Design"
        },
        {
          "content": "iOS"
        },
        {
          "content": "Android"
        }
      ]
    }
  },
  {
    "key": "26990",
    "title": "퍼널: 쏟아지는 페이지 한 방에 관리하기",
    "subtitle": "매끄럽고 우아한 사용자 경험을 위한 개발자의 경험도 우아할 수 있을까요? 수많은 화면과 쏟아지는 분기를 효과적으로 관리하는 ‘퍼널’ 설계에 대해 소개합니다.",
    "publishedTime": "2023-06-08T13:38:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs_low/slash23_thumbs_01_%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%B2%E1%84%85%E1%85%B5%E1%86%B7_low.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "진유림",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "",
    "fullDescription": "",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SLASH23"
        }
      ]
    }
  },
  {
    "key": "slash-23-A1-2",
    "title": "Server-driven UI로 토스의 마지막 어드민 만들기",
    "subtitle": "고객의 소중한 정보를 다루는 ‘어드민 서비스’는 어떻게 만들어져야 할까요? 토스팀의 혁신적인 개발 문화를 뒷받침해주는 안전하고 편리한 어드민 개발 과정을 소개합니다.",
    "publishedTime": "2023-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/slash23/thumbs/slash23_thumbs_04_%E1%84%8C%E1%85%A9%E1%84%8B%E1%85%B2%E1%84%89%E1%85%A5%E1%86%BC.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "조유성",
      "shortDescription": "토스 Frontend UX Engineer"
    },
    "shortDescription": "\n",
    "fullDescription": "\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SLASH23"
        },
        {
          "content": "UX Design"
        }
      ]
    }
  },
  {
    "key": "nodejs-security-contribution",
    "title": "Node.js url.parse() 취약점 컨트리뷰션",
    "subtitle": "토스 보안기술팀은 안전한 금융 서비스를 제공하기 위한 연구를 수행하고 있어요.\n많은 서비스에서 사용되고 있는 Node.js의 취약점을 분석하고 안전하게 패치될 수 있도록 기여했던 과정을 소개드려요.",
    "publishedTime": "2023-05-12T17:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/toss-tech/node%20js-security.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/assets/toss-tech/node%20js-security.png"
    },
    "editor": {
      "name": "표상영",
      "shortDescription": "토스 Security Researcher"
    },
    "shortDescription": "토스 보안기술팀(Security Tech)에서는 개발 서비스 외에도 회사에서 사용하는 프레임워크나 Third-party 시스템의 취약점을 연구하고 있어요.\n이번 아티클에서는 Node.js의 Built-in API 중 하나인 url.parse() 의 Hostname Spoofing 취약점을 발견하고 안전한 코드로 패치될 수",
    "fullDescription": "토스 보안기술팀(Security Tech)에서는 개발 서비스 외에도 회사에서 사용하는 프레임워크나 Third-party 시스템의 취약점을 연구하고 있어요.\n이번 아티클에서는 Node.js의 Built-in API 중 하나인 url.parse() 의 Hostname Spoofing 취약점을 발견하고 안전한 코드로 패치될 수 있도록 컨트리뷰션 했던 과정을 다뤄보려 합니다.\n\n\nurl.parse() 취약점 발생 원인\nNode.js의 url.parse()는 WHATWG URL API가 아닌 자체적인 스펙으로 개발된 함수에요.\nWHATWG URL API\nWHATWG는 Web Hypertext Application Technology Working Group의 약어로 국제 웹 표준화 그룹을 뜻해요. WHATWG URL API 는 국제 표준 스펙으로 URL(Uniform Resource Locator)을 다룰 수 있도록 제공되는 API입니다.  \nWHATWG URL API가 등장하기 전에 자체적으로 개발된 URL 파싱 함수로 보이는데요. 표준 스펙이 아니다 보니 다른 파서(parser)와 결과가 다르고, 이 때문에 예상하기 어려운 코드 흐름도 발생했어요.\nurl.parse()에서는 hostname을 잘못된 방식으로 파싱하는 취약점이 있었는데요. 아래 보이는 Node.js url 라이브러리의 getHostname() 함수에서 발생했어요.\n/* comment\n해당 취약점은 v19.1.0에서 패치되었습니다. \n아래 코드는 v19.1.0 이전 버전에서 확인할 수 있습니다.\n*/\nfunction getHostname(self, rest, hostname) {\n  for (let i = 0; i < hostname.length; ++i) {\n    const code = hostname.charCodeAt(i);\n    const isValid = (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n                    code === CHAR_DOT ||\n                    (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n                    (code >= CHAR_0 && code <= CHAR_9) ||\n                    code === CHAR_HYPHEN_MINUS ||\n                    code === CHAR_PLUS ||\n                    code === CHAR_UNDERSCORE ||\n                    code > 127;\n\n    // Invalid host character\n    if (!isValid) {\n      self.hostname = hostname.slice(0, i);\n      return `/${hostname.slice(i)}${rest}`;\n    }\n  }\n  return rest;\n}\ngetHostname() 함수의 로직은 단순해요. 반복문으로 전달된 문자열의 문자를 하나씩 가져온 뒤, isvalid 조건에 맞는 값을 구하는 로직인데요. 조건에 맞지 않는 문자가 발견되면, 이전 문자까지 문자열을 slice하고 hostname으로 설정해요. 그 뒤로 오는 문자들은 모두 path로 설정하고요.\nisValid 의 조건을 정규식으로 표현해보면 /[a-zA-Z0-9\\.\\-\\+_]/u 와 같은데요(ECMAScript 기준). “hostname으로는 저 범위의 문자들만 올 수 있어!”라고 설정해둔 것이죠. hostname에 올 수 없는 문자열은 모두 path로 정의하고요.\n\n디버깅 코드\nfunction getHostname(self, rest, hostname) {\n    console.log(`[DEBUG] getHostname() arg: ${hostname}`); //debug\n    for (let i = 0; i < hostname.length; ++i) {\n      const code = hostname.charCodeAt(i);\n      const isValid = (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z) ||\n                      code === CHAR_DOT ||\n                      (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n                      (code >= CHAR_0 && code <= CHAR_9) ||\n                      code === CHAR_HYPHEN_MINUS ||\n                      code === CHAR_PLUS ||\n                      code === CHAR_UNDERSCORE ||\n                      code > 127;\n    \n        console.log(`[DEBUG] getHostname(${i}): ${hostname.slice(0, i)}`); //debug\n      // Invalid host character\n      if (!isValid) {\n        console.log(\"[DEBUG] result hostname: \" + hostname.slice(0,i)); //debug\n        self.hostname = hostname.slice(0, i);\n        console.log(`[DEBUG] result path: /${hostname.slice(i)}${rest}`); //debug\n\n        return `/${hostname.slice(i)}${rest}`;\n      }\n    }\n    return rest;\n  }\ngetHostname() 함수에 디버깅 코드를 추가해보면, 실제로 isValid 조건에 해당하지 않는 문자가 반복문에 오면, hostname 파싱을 중단해요. 나머지 문자열은 앞에 / 를 붙여 path로 사용하고요.\n그래서 http://EVIL_DOMAIN*.toss.im 의 hostname이 EVIL_DOMAIN 이 되어버리면서 Hostname Spoofing 취약점이 발생해요.\nHostname Spoofing\nHostname Spoofing은 시스템을 대상으로 Hostname을 속이는 해킹 기법을 말합니다.\nSpoofing은 ‘속이다’라는 사전적 의미를 갖고 있으며, 시스템을 대상으로 어떠한 정보를 속이는 해킹 기법을 Spoofing이라고 합니다.\n\n\nWHATWG URL API ↔ url.parse() 비교\n반면 WHATWG URL AP 의 hostname 파싱 결과는 evil_domain*.toss.im 입니다. \n\n\nReserved Characters\nNode.js에서 hostname을 왜 이렇게 파싱할까요? RFC 3986는 Standard URI Syntax 를 정의해둔 문서인데요. 2.2 Reserved Characters를 보면 그 이유를 찾을 수 있어요.\n\nReserved Characters는 URI를 구성할 수 있으면서 특수 목적을 가진 문자가 예약된 것입니다. 예시로는 port 구분자로 사용되는 : 또는  path 구분자로 사용되는 /가 있어요.  따라서, *, !, $, :, # 와 같은 문자들은 hostname으로 사용할 수 없습니다. 정의된 문자들은 gethostName()의 isValid 조건과 비슷하죠.\n취약점 악용 시나리오\n이러한 WHATWG URL API ↔ url.parse() 간 파싱 결과 차이는 서비스의 도메인 검증로직을 우회하는데 악용할 수 있어요. 간단한 예시를 함께 살펴볼게요.\n// server.ts (exec command: ts-node server.ts)\n/* dependencise\n\texpress@^4.18.1\n\tts-node@^10.9.1\n\ttypescript@^4.3.2\n\tnode-fetch@2\n\t@types/node-fetch@^2.6.2\n*/\nimport express, { Request, Response, NextFunction } from 'express';\n\nconst node_fetch = require(\"node-fetch\");\nconst app = express();\n\napp.get(\"/image/resize\", async (req: Request, res: Response) => {\n\t// GET메소드로 url파라미터 입력 받음\n\tconst url = req.query.url as string; \n\t// WHATWG URL API를 이용해 hostname 파싱\n\tconst host = new URL(url).hostname; \n\n\t// 파싱한 hostname 검증 (example.com과 *.example.com일 경우에만 분기문 통과)\n\tif(host === \"toss.im\" || host.endsWith(\".toss.im\")) { \n\t\t// 검증된 hostname일 경우, node_fetch로 http request\n\t\tvar result = await node_fetch.default(url); \n\t\tvar requestUrl = result.url; \n\t\t// 파라미터로 입력된 url과 node_fetch로 실제 요청한 url 콘솔 출력\n\t\tconsole.log(`Input URL: ${url} / Request URL: ${requestUrl}`);\n\t// 그 외 경우는 reject\n\t} else {\n\t\tconsole.log(\"reject\");\n\t}\n});\n\napp.listen(4540, () => {\n});\n위 코드는 파라미터로 URL을 입력받고, 입력된 URL을 검증 후 fetch하는 간단한 웹서버인데요. WHATWG URL API로 hostname을 가져온 뒤, toss.im 과 일치하거나 .toss.im 으로 끝나는지 도메인을 검증해요.\n\nURL 파라미터 값을 https://google.com!.toss.im 로 입력하면 검증 로직이 우회되고 서버는 https://google.com/!.toss.im/ 으로 요청하게 되는데요. 그 이유는 아래 node-fetch 라이브러리 코드를 보면 알 수 있어요.\n/* node-fetch v2.6.11 \n * [https://github.com/node-fetch/node-fetch/tree/v2.6.11]\n * request.js\n *\n * Request class contains server only options\n *\n * \n */\n\nimport Url from 'url'; // [1]\nimport Stream from 'stream';\nimport whatwgUrl from 'whatwg-url';\nimport Headers, { exportNodeCompatibleHeaders } from './headers.js';\nimport Body, { clone, extractContentType, getTotalBytes } from './body';\n\nconst INTERNALS = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse; // [2]\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n\t\tCheck whether the URL is absolute or not\n\n\t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n\t\tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n\t*/\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString() // [3]\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr); // [4]\n}\n위 코드는 node-fetch 라이브러리에서 URL을 파싱하는 코드 부분입니다. 중요한 부분은 주석으로 번호 표시를 해두었는데요.\n[1] Node.js의 url 라이브러리를 가져옵니다.\n[2] Node.js의 url.parse()함수를 parse_url 변수에 저장합니다.\n[3] 파싱할 URL이 /^[a-zA-Z][a-zA-Z\\d+\\-.]*:/ 정규식 조건과 일치하면 WHATWG URL API로 파싱합니다.\n[4] 그 외에 경우는 Node.js의 url.parse()함수로 파싱합니다.\nhttps://google.com!.toss.im 은 [3] 정규식 조건에 충족되지 않으니, [4] url.parse()로 hostname이 파싱되었고 Node.js의 잘못된 파싱 방식으로 인해 검증 로직이 우회된 것이죠.\n이런 예시와 같이 서비스 서버의 검증 로직을 우회하고 공격자가 원하는 임의의 도메인으로 요청하도록 하는 공격기법을 SSRF(Server Side Request Forgery)라고 하는데요. 공격자는 SSRF 공격을 통해 외부에 공개되어 있지 않은 서비스 내부 망에 접근하여 민감한 정보들을 탈취하거나, 관리자 기능들을 악용할 수 있어요.\n취약점 패치 컨트리뷰션\n화이트해커 문화에는 취약점을 제보하고 그에 따른 보상을 받는 버그바운티(Bug Bounty) 프로그램이 있어요. 보안에 중요한 가치를 두고 있는 기업들이 독립적으로 운영하거나 국가기관에서 운영하기도 하는데요. 토스에서도 작년에 토스 버그바운티 챌린지를 진행한 바 있고, 국가 기관에서는 한국인터넷진흥원(KISA)이 국내 소프트웨어에 대한 취약점을 제보받고 있어요.\n\n저 또한 버그바운티 프로그램을 통해 Node.js 측에 취약점을 제보하였고, 취약점을 알맞게 패치할 수 있는 방안들에 대해 논의하면서 컨트리뷰션을 시작했어요.\n\n기존에 Unreserved Characters 를 화이트리스트로 처리하는 방식 대신 Reserved Characters 를 블랙리스트로 처리하는 방식으로 변경하여 isValid 조건을 좀 더 엄격하게 가져가도록 패치했어요.\n\n패치된 코드는 Pull Request에서 확인할 수 있고, 해당 Pull Request는 v19.1.0, v18.13.0 에서 적용됐어요.\n\n추가로 기존에 Legacy 상태였던 url.parse()함수를 Deprecated로 변경하였는데요. --pending-deprecation 옵션을 사용하는 경우, 런타임에서 Deprecated 함수임을 경고하도록 패치되었습니다.\n\n\n이 글을 읽으신 분들도 Node.js를 사용하고 계시다면, 취약점이 존재하는 버전을 사용 중인지 확인해보세요. *취약점은 v19.1.0, v18.13.0 에서 패치되었습니다.\n그리고 저희 보안기술팀(Security Tech)에서 이와 같은 보안 연구를 같이 해나갈 동료분들을 찾고 있습니다. 관심이 있으시다면 언제든지 문을 두드려 주세요!\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Security"
        },
        {
          "content": "Node.js"
        }
      ]
    }
  },
  {
    "key": "how-to-work-health-check-in-spring-boot-actuator",
    "title": "Spring Boot Actuator의 헬스체크 살펴보기",
    "subtitle": "서버의 상태를 알려주는 헬스 체크에 대해 알고 계시나요? 단순히 200 OK만 내려주겠거니 하고 별로 신경을 안 쓰고 계셨나요? 해당 포스트에서는 Spring Boot Actuaor가 제공해주는 헬스 체크는 어떤 식으로 서버의 상태를 점검하는지, 어떤 부분을 주의하며 사용해야하는지 알아봅니다.",
    "publishedTime": "2023-04-01T15:38:57+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-tech-cover.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/illusts-content/img-tech-cover.png"
    },
    "editor": {
      "name": "양권성",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "\n뭐든 알고 쓰는 게 참 중요한 것 같습니다. 단순히 “지금은 잘 돌아가니까 문제 없다”는 접근은 문제가 발생하기 전까지는 문제를 방치하기 마련입니다.\n사용하는 기술이나 구조에 대해 끊임없이 질문을 던지고 탐구하는 과정은 토스팀 코어밸류 3.0 중 하나인 Question Every Assumption, 모든 기본 가정에 ",
    "fullDescription": "\n뭐든 알고 쓰는 게 참 중요한 것 같습니다. 단순히 “지금은 잘 돌아가니까 문제 없다”는 접근은 문제가 발생하기 전까지는 문제를 방치하기 마련입니다.\n사용하는 기술이나 구조에 대해 끊임없이 질문을 던지고 탐구하는 과정은 토스팀 코어밸류 3.0 중 하나인 Question Every Assumption, 모든 기본 가정에 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "Spring"
        },
        {
          "content": "Kotlin"
        }
      ]
    }
  },
  {
    "key": "improving-code-quality-via-eslint-and-ast",
    "title": "ESLint와 AST로 코드 퀄리티 높이기",
    "subtitle": "ESLint와 AST로 토스에서 코드 퀄리티를 높인 방법에 대해 소개드려요.",
    "publishedTime": "2023-03-31T15:47:53+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/03/center.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/03/center.png"
    },
    "editor": {
      "name": "전성",
      "shortDescription": "토스 Frontend Platform Engineer"
    },
    "shortDescription": "코딩 컨벤션을 일관적으로 유지하기\n일관적인 코딩 컨벤션을 가지면 코드를 읽기 쉬워지고, 안티패턴을 방지할 수 있습니다. 결과로 버그도 줄고, 코드를 쉽게 유지보수할 수 있죠.\n하지만 이것을 사람이 직접 적용하는 것은 한계가 있기 때문에, 여러 가지 정적 분석 도구를 활용하게 됩니다. JavaScript/TypeScript",
    "fullDescription": "코딩 컨벤션을 일관적으로 유지하기\n일관적인 코딩 컨벤션을 가지면 코드를 읽기 쉬워지고, 안티패턴을 방지할 수 있습니다. 결과로 버그도 줄고, 코드를 쉽게 유지보수할 수 있죠.\n하지만 이것을 사람이 직접 적용하는 것은 한계가 있기 때문에, 여러 가지 정적 분석 도구를 활용하게 됩니다. JavaScript/TypeScript",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "테스트"
        }
      ]
    }
  },
  {
    "key": "tosspayments-restdocs",
    "title": "tosspayments-restdocs: 선언형 문서 작성 라이브러리",
    "subtitle": "REST Docs 를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 기술들을 소개합니다.",
    "publishedTime": "2023-03-22T14:29:51+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/03/00017-3291509353.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/03/00017-3291509353.png"
    },
    "editor": {
      "name": "이준희",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "최소한의 코드로 문서 작성하기\n들어가며\n토스페이먼츠에서는 두 가지 장점 때문에 Spring REST Docs를 권장하고 있는데요. 첫 번째는 문서 작성 단계부터 API를 통합 테스트할 수 있다는 점, 두 번째는 인터페이스의 의도치 않은 변경을 감지할 수 있다는 점 때문입니다.\n하지만 Spring REST Docs에는 단점",
    "fullDescription": "최소한의 코드로 문서 작성하기\n들어가며\n토스페이먼츠에서는 두 가지 장점 때문에 Spring REST Docs를 권장하고 있는데요. 첫 번째는 문서 작성 단계부터 API를 통합 테스트할 수 있다는 점, 두 번째는 인터페이스의 의도치 않은 변경을 감지할 수 있다는 점 때문입니다.\n하지만 Spring REST Docs에는 단점",
    "seoConfig": {
      "tags": [
        {
          "content": "생산성"
        },
        {
          "content": "Server"
        },
        {
          "content": "Spring"
        }
      ]
    }
  },
  {
    "key": "frontend-declarative-code",
    "title": "선언적인 코드 작성하기",
    "subtitle": "선언적인 코드, 토스 프론트엔드 챕터는 어떻게 생각을 하고 있을까요?",
    "publishedTime": "2023-03-16T21:41:13+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/03/declarative.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/03/declarative.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "선언적인 코드(Declarative Code)는 프론트엔드 개발을 하다 보면 자주 만나게 되는 개념입니다. 특히 React 생태계에서 웹 서비스를 개발하다 보면 선언적인 코드에 대해 고민하게 되는데요. 이번 아티클에서는 토스 프론트엔드 챕터에서 생각하는 선언적인 코드란 무엇인지, 그리고 실제로 어떻게 선언적인 코드를 작성",
    "fullDescription": "선언적인 코드(Declarative Code)는 프론트엔드 개발을 하다 보면 자주 만나게 되는 개념입니다. 특히 React 생태계에서 웹 서비스를 개발하다 보면 선언적인 코드에 대해 고민하게 되는데요. 이번 아티클에서는 토스 프론트엔드 챕터에서 생각하는 선언적인 코드란 무엇인지, 그리고 실제로 어떻게 선언적인 코드를 작성하는지 공유해드리려고 합니다.\n선언적인 코드\n토스 프론트엔드 챕터에서는 선언적인 코드를 “추상화 레벨이 높아진 코드”로 생각하고 있습니다. 예를 들어서, 아래와 같이 주어진 배열의 합을 구하는 함수 sum 을 생각해봅시다.\nsum([1, 2, 3]);\nsum 함수는 아래와 같이 for 문으로 구현할 수 있습니다.\nfunction sum(nums: number[]) {\n  let result = 0;\n\n  for (const num of nums) {\n    result += num;\n  }\n\n  return result;\n}\n여기에서 sum 함수는 초기값이 0이고, 배열이 가지고 있는 각각의 원소를 순회하면서 결과값에 더하는 작업을 추상화합니다. 덕분에 sum 을 다루는 사람은 복잡한 제어 흐름을 이해할 필요 없이, “배열의 합을 구한다” 라고 하는 동작에 집중하여 함수를 사용할 수 있습니다.\n토스는 이렇게 동작에 집중하여 추상화된 sum 함수를 선언적인 코드로 생각하고 있습니다.\n여기에서 한 걸음 더 나아가서 sum 함수 내부의 for ... of 문을 살펴봅시다.\nfor (const num of nums) {\n  /* 동작 ... */\n}\n이 제어 흐름도 선언적인 코드로 볼 수 있습니다. 배열이 가지고 있는 각각의 요소를 순회하는 동작을 추상화하고 있기 때문입니다.\n실제로 ECMAScript 표준에 따라서 for ... of 가 추상화하는 로직을 그대로 드러내면 아래와 같이 나타낼 수 있습니다.\nconst iterator = nums[Symbol.iterator]();\n\nlet step;\n\nwhile (!(step = iterator.next()).done) {\n  const num = step;\n  /* 동작 ... */\n}\n위와 같이, for ... of 문은 Iterator를 생성하고, Iterator가 끝날 때까지 다음 요소를 차례차례 가져오는 작업을 “각각의 요소를 순회하는 작업”으로 추상화합니다. 이런 관점에서 봤을 때, for ... of 문은 선언적인 코드입니다.\n실제로는 생성된 Iterator를 삭제하는 동작도 존재하므로 보다 추상화되는 로직이 많습니다.\n코드의 관점을 벗어나면 보다 재미있는 예시를 생각할 수 있습니다.\n“왼쪽으로 10걸음 걸어라” 라고 하는 말을 생각합시다. 여기에서\n“왼쪽”은 “북쪽을 바라보았을 때 90도 돌아간 위치” 를 추상화한 것입니다.\n“90도”는 “한 번의 회전을 360등분한 각의 90배만큼 시초선에 대해 시계 반대 방향으로 돌아간 것” 을 추상화한 것입니다.\n“시계 방향” 의 정의는 “북반구에서 해시계의 바늘이 돌아가는 방향” 을 추상화한 것입니다.\n그래서 “왼쪽으로 10걸음 걸어라”는 사실 “북쪽을 바라보았을 때 한 번의 회전을 360등분한 각의 90배만큼 북반구에서 해시계의 바늘이 돌아가는 방향으로 돌아서, 동물이 육상에서 다리를 이용해 움직이는 가장 빠른 방법보다 느린, 신체를 한 지점에서 다른 지점으로 옮겨가는 행위를 10번 반복해라” 라는 말을 추상화한, 선언적인 말로 볼 수 있을 것입니다.\n좋은 선언적인 코드 작성하기\n위에서 선언적인 코드를 추상화 레벨이 높아진 코드로 살펴보았습니다. 그런데 선언적인 코드는 항상 좋은 것일까요? 토스에서는 추상화가 항상 좋은 것은 아닌 것처럼 선언적인 코드도 잘 쓰는 것이 중요하다고 생각합니다.\n토스에서는 좋은 코드를 판단하는 제1원칙을 “수정하기 쉬운 코드”라고 생각합니다. 비즈니스 요구사항은 항상 빠르게 변하기 때문에, 개발자가 기민하게 대응하는 것이 중요하기 때문입니다. 그러면 선언적인 코드가 언제 수정하기 쉽고, 언제 그렇지 않은지 살펴봅시다.\n먼저 아래와 같은 회원가입 폼 컴포넌트를 살펴봅시다.\n<SignUpForm\n  onSubmit={result => {\n    /* 회원가입 결과에 따라서 특정 동작 수행 ... */\n  }}\n/>\n위 컴포넌트는 회원가입 로직을 하나의 컴포넌트로 추상화했기 때문에 선언적인 컴포넌트로 볼 수 있습니다.\n이 코드는 수정하기 쉬울까요?\n먼저 회원가입 폼을 여러 곳에서 사용한다면 각각의 폼을 중복해서 개발할 필요 없이 한 번만 개발하면 되기 때문에 효율적일 것입니다. 또한 회원가입 폼에 변경이 생긴다고 하더라도, 한 곳에서만 바꾸면 다른 화면들에 모두 반영되기 때문에 빨리 수정할 수 있을 것입니다.\n수정하기 어려운 지점은 없을까요?\n화면마다 SignUpForm 이 조금씩 다르다면, 공통화된 것이 오히려 코드의 복잡함을 가져올 수도 있습니다. 예를 들어서, 어떤 페이지에서는 SNS 회원가입을 일반 이메일 회원가입보다 먼저 보여줘야 할 수 있습니다. 또, 다른 페이지에서는 텍스트나 스타일을 조금씩 다르게 보여줘야 할 수 있습니다.\n아래와 같이 SignUpForm 에서 바뀔 수 있는 부분이 많다면, 내부 구현과 인터페이스도 복잡해지고, 쓰는 쪽에서도 불편할 것입니다.\n<SignUpForm\n  signUpOrder={['sns', 'normal']\n  title=\"사이트에 어서 오세요\"\n  subtitle=\"먼저 회원가입을 해주세요.\"\n  primaryButtonColor={colors.blue}\n  secondaryButtonColor={colors.grey}\n  /* 많은 Prop 들 ... */\n  onCancel={/* ... */}\n  onSubmit={result => {\n    /* 회원가입 결과에 따라서 특정 동작 수행 ... */\n  }}\n/>\n이처럼 토스에서는 선언적인 코드가 항상 좋은 것이 아니라, 앞으로 제품이 어떻게 변화할지, 비즈니스 요구사항이 어떻게 되는지에 따라서 달라질 수 있다고 생각하고 있습니다. 앞으로 코드의 어떤 부분이 수정될지 예측하고, 이에 따라 적절한 선언 레벨을 따르는 코드를 작성할 필요가 있습니다.\n토스의 선언적 라이브러리\n그렇다면 다양한 상황에서 일반적으로 사용할 수 있는 좋은 선언적 코드는 없을까요? 이번 아티클은 토스 프론트엔드 챕터가 100개가 넘는 서비스들에서 자주 사용하고 있는 선언적 라이브러리에 대해서 소개하고 마무리하려고 합니다.\nuseOverlay\n\n토스에서는 BottomSheet, Dialog, Toast와 같이 화면 위에 뜨는 오버레이를 띄워야 하는 상황이 많습니다. 토스는 이렇게 오버레이를 띄우는 동작을 추상화하여 useOverlay 라고 하는 Hook 을 사용합니다.\nconst overlay = useOverlay();\n\n<button\n  onClick={() => {\n    overlay.open(({ isOpen, close }) => {\n      return (\n        <BottomSheet open={isOpen} onClose={close}>\n          나는 바텀시트야\n        </BottomSheet>\n      );\n    })\n  }}\n>\n  바텀시트 열기\n</button>\n예를 들어서, 위 코드에서는 바텀시트 열기 버튼을 누르면 나는 바텀시트야 라고 하는 바텀시트를 띄웁니다.\nuseOverlay 가 없었더라면 아래와 같이 제어 흐름이 드러나는 코드를 작성했어야 할 것입니다.\nconst [isSheetOpen, setIsSheetOpen] = useState(false);\n\n<button onClick={() => setIsSheetOpen(true)}>\n  바텀시트 열기\n</button>\n<BottomSheet open={isSheetOpen} onClose={() => setIsSheetOpen(false)}>\n  나는 바텀시트야\n</BottomSheet>\n\nuseOverlay에 대한 자세한 정보는 Slash libraries의 useOverlay Hook을 참고해주세요.\nImpressionArea\n토스 앱에서는 어떤 영역이 보여졌는지/숨겨졌는지에 따라서 동작하는 로직이 많습니다. 예를 들어서, 사용자가 특정한 요소를 보면 폭죽을 터뜨리거나 토스트를 보여주는 식이죠. 토스에서는 ImpressionArea 라고 하는 컴포넌트로 이를 추상화하고 있습니다.\n<ImpressionArea onImpressionStart={() => { /* 보여졌을 때 실행 */ }}>\n  <div>내가 보여졌으면 onImpressionStart가 실행돼</div>\n</ImpressionArea>\n\nImpressionArea 가 없었더라면, 복잡한 IntersectionObserver API 를 사용하거나, 복잡한 Scroll 이벤트 핸들러 로직을 사용해야 했을 것입니다.\nImpressionArea 에 대한 자세한 정보는 Slash libraries의 ImpressionArea 컴포넌트를 참고해주세요.\nLoggingClick\n토스에서는 데이터 주도 의사결정을 위해서 화면에 진입하는 사용자가 몇 명인지, 그 중 몇 명이 버튼을 누르는지를 기록하는 경우가 있습니다. 이런 누르는 동작에 대한 기록을 추상화하여 LoggingClick 컴포넌트를 사용하고 있습니다.\n<LoggingClick params={{ price }}>\n  <button onClick={buy}>사기</button>\n</LoggingClick>\n\n예를 들어서, 위 코드에서 사용자가 버튼을 누르면 “사기” 버튼에 대한 동작이 분석 시스템에 기록됩니다.\nLoggingClick 이 없었다면 아래와 같이 log 함수를 실행하는 것이 그대로 드러났어야 할 것입니다.\n<button\n  onClick={() => {\n    log({ title: '사기', price });\n    buy();\n  }}\n>\n  사기\n</button>\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "리팩토링"
        }
      ]
    }
  },
  {
    "key": "smart-polyfills",
    "title": "똑똑하게 브라우저 Polyfill 관리하기",
    "subtitle": "현대적인 JavaScript를 쓰면서도 넓은 범위의 기기를 지원하기 위한 Polyfill을 어떻게 똑똑하게 설정할 수 있는지 소개합니다.",
    "publishedTime": "2023-01-21T12:52:16+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/01/js_center.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2023/01/js_center.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "토스 앱은 넓은 범위의 기기를 지원하면서도 현대적인 JavaScript를 이용해서 개발되고 있습니다. 그렇지만 최신 JavaScript를 오래된 브라우저 위에서 실행하기 위해서는 “Polyfill” 문제를 해결해야 하는데요.\n이번 아티클에서는 Polyfill 문제가 무엇인지 알아보고, 토스에서 어떻게 똑똑하게 다루고 있는",
    "fullDescription": "토스 앱은 넓은 범위의 기기를 지원하면서도 현대적인 JavaScript를 이용해서 개발되고 있습니다. 그렇지만 최신 JavaScript를 오래된 브라우저 위에서 실행하기 위해서는 “Polyfill” 문제를 해결해야 하는데요.\n이번 아티클에서는 Polyfill 문제가 무엇인지 알아보고, 토스에서 어떻게 똑똑하게 다루고 있는",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "JavaScript"
        }
      ]
    }
  },
  {
    "key": "tossinvest-qa-integration-test",
    "title": "토스증권 QA 문화 ‘통합테스트’를 아시나요? (feat. 해외주식)",
    "subtitle": "토스증권 해외주식 출시 전에 사내 임직원 대상으로 진행한 ‘통합테스트’에 대해 소개합니다. 통합테스트 진행 방식을 참고하여 간단한 규칙과 사용자 시나리오를 활용해 사용자의 반응을 미리 확인해 보세요.",
    "publishedTime": "2022-12-12T21:01:48+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/12/01-1.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/12/01-1.png"
    },
    "editor": {
      "name": "황채은",
      "shortDescription": "토스증권 QA Manager"
    },
    "shortDescription": "\n안녕하세요. 토스증권 QA팀에서 일하고 있는 QA Manager 황채은입니다.\n지난 글에서 잠깐 언급되었던 토스증권의 Closed Beta Test 기억하실까요? 🔗지난 포스팅 참고하기 링크\n오늘은 해외 증권 서비스 출시를 위해 토스증권 임직원 대상으로 진행한 Closed Beta Test 에 대해 소개하려고 합니다.\n",
    "fullDescription": "\n안녕하세요. 토스증권 QA팀에서 일하고 있는 QA Manager 황채은입니다.\n지난 글에서 잠깐 언급되었던 토스증권의 Closed Beta Test 기억하실까요? 🔗지난 포스팅 참고하기 링크\n오늘은 해외 증권 서비스 출시를 위해 토스증권 임직원 대상으로 진행한 Closed Beta Test 에 대해 소개하려고 합니다.\n",
    "seoConfig": {
      "tags": [
        {
          "content": "테스트"
        },
        {
          "content": "QA"
        }
      ]
    }
  },
  {
    "key": "nestjs-custom-decorator",
    "title": "NestJS 환경에 맞는 Custom Decorator 만들기",
    "subtitle": "NestJS에서 데코레이터를 만들기 위해서는 NestJS의 DI와 메타 프로그래밍 환경 등을 고려해야 합니다. 어떻게 하면 이러한 NestJS 환경에 맞는 데코레이터를 만들 수 있을지 고민해보았습니다.",
    "publishedTime": "2022-11-22T00:03:49+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/11/tech-article-nest-js-02.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/11/tech-article-nest-js-02.png"
    },
    "editor": {
      "name": "송현지",
      "shortDescription": "토스 Node.js Developer"
    },
    "shortDescription": "들어가며\n데코레이터는 비즈니스와 상관 없는 로직들을 숨기면서 기능을 변경하거나 확장할 수 있게 합니다. 또한 여러 클래스에서 반복되는 공통 관심사가 있을 때 데코레이터를 사용하면 중복된 코드를 줄이고 코드를 모듈 단위로 관리하는 효과를 거둘 수 있습니다.\n\n이런 이유로 저희 Node.js Chapter에서도 데코레이터를 ",
    "fullDescription": "들어가며\n데코레이터는 비즈니스와 상관 없는 로직들을 숨기면서 기능을 변경하거나 확장할 수 있게 합니다. 또한 여러 클래스에서 반복되는 공통 관심사가 있을 때 데코레이터를 사용하면 중복된 코드를 줄이고 코드를 모듈 단위로 관리하는 효과를 거둘 수 있습니다.\n\n이런 이유로 저희 Node.js Chapter에서도 데코레이터를 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Node.js"
        },
        {
          "content": "NestJS"
        }
      ]
    }
  },
  {
    "key": "typescript-type-compatibility",
    "title": "TypeScript 타입 시스템 뜯어보기: 타입 호환성",
    "subtitle": "타입호환성은 무엇이며 왜 필요할까요? 타입호환이 지원되지 않는 경우가 존재한다는 것을 아셨나요? 평소 익숙했던 개념들에 대해 질문을 던져가며 TypeScript 타입 시스템에 관해 심도있게 알아보고자 합니다.",
    "publishedTime": "2022-10-26T00:38:54+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/10/tech-article-ts.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/10/tech-article-ts.png"
    },
    "editor": {
      "name": "김병묵",
      "shortDescription": "토스플레이스 Node.js Developer"
    },
    "shortDescription": "들어가며\n토스 Node.js 챕터에서는 높은 코드 가독성과 품질을 위해 TypeScript의 타입 시스템을 적극적으로 활용하고 있고 이에 대한 이해도를 높이기 위해 스터디를 꾸준히 진행하고 있습니다. TypeScript의 타입 시스템에 대해 공부해보던 중 알게된 흥미로운 몇가지 토픽들을 소개하려 합니다. 그 중 한가지로 ",
    "fullDescription": "들어가며\n토스 Node.js 챕터에서는 높은 코드 가독성과 품질을 위해 TypeScript의 타입 시스템을 적극적으로 활용하고 있고 이에 대한 이해도를 높이기 위해 스터디를 꾸준히 진행하고 있습니다. TypeScript의 타입 시스템에 대해 공부해보던 중 알게된 흥미로운 몇가지 토픽들을 소개하려 합니다. 그 중 한가지로 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Node.js"
        },
        {
          "content": "TypeScript"
        }
      ]
    }
  },
  {
    "key": "tosssec-qateam",
    "title": "토스증권 QA Team을 소개합니다",
    "subtitle": "이 글은 토스증권 QA Team에 입사를 고려 중인 지원자들을 위해 작성된 글입니다. 토스증권 QA Manager 하는 역할과 일하는 방식은 어떻게 다를까요?",
    "publishedTime": "2022-10-25T15:48:53+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/10/tech_M.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/10/tech_M.png"
    },
    "editor": {
      "name": "곽수정",
      "shortDescription": "토스증권 QA Manager"
    },
    "shortDescription": "안녕하세요. 저는 3년 전 토스의 첫 QA Manager로 입사해서 현재 토스증권 QA팀에서 일하고 있는 곽수정입니다. 길다면 긴 3년이란 시간 동안 즐겁고 재밌게 일할 수 있었던 토스와 토스증권의 QA팀을 소개해보려고 해요.\nQA가 없었던 토스팀, 왜 첫 번째 QA Manager를 채용하게 되었을까요?\n초창기의 토스팀은",
    "fullDescription": "안녕하세요. 저는 3년 전 토스의 첫 QA Manager로 입사해서 현재 토스증권 QA팀에서 일하고 있는 곽수정입니다. 길다면 긴 3년이란 시간 동안 즐겁고 재밌게 일할 수 있었던 토스와 토스증권의 QA팀을 소개해보려고 해요.\nQA가 없었던 토스팀, 왜 첫 번째 QA Manager를 채용하게 되었을까요?\n초창기의 토스팀은",
    "seoConfig": {
      "tags": [
        {
          "content": "테스트"
        },
        {
          "content": "QA"
        }
      ]
    }
  },
  {
    "key": "commonjs-esm-exports-field",
    "title": "CommonJS와 ESM에 모두 대응하는 라이브러리 개발하기: exports field",
    "subtitle": "Node.js에는 두 가지 Module System이 존재합니다. 토스 프론트엔드 챕터에서 운영하는 100개가 넘는 라이브러리들은 그것에 어떻게 대응하고 있을까요?",
    "publishedTime": "2022-10-04T17:37:32+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/10/techblog-11-node-js.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/10/techblog-11-node-js.png"
    },
    "editor": {
      "name": "장호승",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "들어가며\n토스 프론트엔드 챕터에서는 개발 생산성을 극대화하기 위해 코드를 지속적으로 라이브러리로 만들고 있습니다. 그 결과 지금은 100개가 넘는 라이브러리를 운영하고 있습니다.\nNode.js 12부터 ECMAScript Modules라는 새로운 Module System이 추가되면서, 기존의 CommonJS라는 Modul",
    "fullDescription": "들어가며\n토스 프론트엔드 챕터에서는 개발 생산성을 극대화하기 위해 코드를 지속적으로 라이브러리로 만들고 있습니다. 그 결과 지금은 100개가 넘는 라이브러리를 운영하고 있습니다.\nNode.js 12부터 ECMAScript Modules라는 새로운 Module System이 추가되면서, 기존의 CommonJS라는 Modul",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "Node.js"
        },
        {
          "content": "CommonJS"
        }
      ]
    }
  },
  {
    "key": "how-to-manage-test-dependency-in-gradle",
    "title": "테스트 의존성 관리로 높은 품질의 테스트 코드 유지하기",
    "subtitle": "혹시 테스트 코드에서도 의존성을 관리해본 적이 있으실까요? 해당 포스트에서는 Gradle의 java-test-fixtures 플러그인을 사용하여 테스트 의존성 관리를 통해 높은 품질의 테스트 코드를 유지하는 방법을 알아봅니다.",
    "publishedTime": "2022-06-09T00:17:10+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/06/techblog-10-test-code.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/06/techblog-10-test-code.png"
    },
    "editor": {
      "name": "양권성",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "테스트 코드는 애플리케이션 코드 못지 않게 높은 품질을 유지해야 합니다.\n낮은 품질(이해하기 어려운 코드, 여기저기 깨져있는 테스트)의 테스트는 유지보수가 어렵고 기술부채에 못지 않은 부채로 다가옵니다.\n그래서 테스트 코드의 높은 품질을 유지하기 위해 다양한 Builder, Helper 클래스들이 나오게 되고, 테스트 전",
    "fullDescription": "테스트 코드는 애플리케이션 코드 못지 않게 높은 품질을 유지해야 합니다.\n낮은 품질(이해하기 어려운 코드, 여기저기 깨져있는 테스트)의 테스트는 유지보수가 어렵고 기술부채에 못지 않은 부채로 다가옵니다.\n그래서 테스트 코드의 높은 품질을 유지하기 위해 다양한 Builder, Helper 클래스들이 나오게 되고, 테스트 전",
    "seoConfig": {
      "tags": [
        {
          "content": "테스트"
        },
        {
          "content": "Server"
        },
        {
          "content": "Gradle"
        }
      ]
    }
  },
  {
    "key": "27450",
    "title": "토스뱅크의 완전히 새로운 대출 시스템",
    "subtitle": "2022년 1월 1일, 토스뱅크 대출 오픈런을 견뎌낸 토스뱅크 대출의 시스템은 어떻게 구성되었는지 살펴봅니다. 토스뱅크의 시스템 아키텍처를 공유하고 DB 스키마를 안전하게 설계하는 방법과 Kafka, Redis를 활용한 유량제어 시스템을 공유합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/assets/homepage/slash22/list_thumbnail/list_thumbnail_11.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "민재슬",
      "shortDescription": "토스뱅크 Server Developer"
    },
    "shortDescription": " \n\n\n",
    "fullDescription": " \n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27434",
    "title": "왜 은행은 무한스크롤이 안되나요",
    "subtitle": "은행 앱에서 한 달 전의 통장 거래내역을 보기 위해서는 스크롤을 이용할 수 없습니다. 귀찮더라도 조회 기간을 입력해야 하죠. 사실 이건 모든 은행의 서버 아키텍처와 관련된 문제이기도 합니다. 그렇다면 토스뱅크는 이 문제를 어떻게 해결했을까요?",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_12.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이응준",
      "shortDescription": null
    },
    "shortDescription": "  \n\n",
    "fullDescription": "  \n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27432",
    "title": "Data Scientist는 어떻게 비즈니스에 기여할 수 있을까?",
    "subtitle": "토스의 데이터 사이언티스트는 ‘사일로’라고 불리는 제품팀과 긴밀하게 협업합니다. 머신 러닝(Machine Learning) 기술을 통해 사일로의 니즈를 효율적으로 해소하기 위한 데이터 사이언티스트들의 여정을 공유합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_10.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "황동현",
      "shortDescription": "토스 Data Scientist"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Data"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27430",
    "title": "스크래핑으로 우아한 조회 경험을 만든 방법",
    "subtitle": "토스의 조회 서비스, 사용해본 적 있나요? 마이데이터 이전, 스크래핑으로 개발한 제품을 운영하면서 마주쳤던 문제들과 해결 과정을 공유합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_9.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김용성",
      "shortDescription": "토스 Node.js Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH22"
        },
        {
          "content": "Node.js"
        }
      ]
    }
  },
  {
    "key": "27428",
    "title": "금융의 모든 순간을 자동화할 때 까지 Toss Crazy Activation",
    "subtitle": "불편한 사용자 경험은 이제 그만. 토스의 사용자라면 생년월일, 전화번호, 이름과 같은 정보를 반복해서 입력하지 않도록 만든 웹 자동화 기술의 핵심 아이디어를 소개합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_8.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "정세훈",
      "shortDescription": "토스 Node.js Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH22"
        },
        {
          "content": "Node.js"
        }
      ]
    }
  },
  {
    "key": "27426",
    "title": "Effective Component 지속 가능한 성장과 컴포넌트",
    "subtitle": "우리는 왜 컴포넌트를 나누어 개발해야 할까요? 토스가 정의하는 컴포넌트의 역할과 분리 기준을 공유합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_7.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "한재엽",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27424",
    "title": "지속 성장 가능한 코드를 만들어가는 방법",
    "subtitle": "우리가 만드는 코드가 처음부터 완벽할 수는 없습니다. 하지만 서비스가 폭발적으로 성장하려고 할 때 발목을 잡아선 안 되죠. 하루 이틀 운영되고 끝인 게 아닌, 오래 살아 있을 수 있는 좋은 소프트웨어는 어떤 모습일까요?",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_6.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김재민",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27422",
    "title": "잃어버린 유저의 시간을 찾아서: 100년을 아껴준SSR 이야기",
    "subtitle": "토스 웹페이지의 한 달 방문 횟수는 약 2억 번에 달합니다. 많은 횟수만큼 유저가 기다리는 시간도 상당했을 겁니다. 서버 사이드 렌더링(SSR)을 이용해 유저의 시간을 아낀 경험을 소개합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_5.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김도환",
      "shortDescription": "토스 Frontend DevOps Engineer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27420",
    "title": "애플 한 주가 고객에게 전달 되기까지 ",
    "subtitle": "MSA로 구성된 토스증권 해외주식 시스템의 주문 과정에서 동시성을 안전하게 처리하는 방법과 브로커 장애와 격리된 서비스 구성을 소개합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_14.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이승천",
      "shortDescription": "토스증권 Server Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "MSA"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27418",
    "title": "은행 앱에도 Service Mesh 도입이 가능한가요?",
    "subtitle": "토스뱅크에서 안정적으로 서비스를 운영하기 위해 구성한 아키텍처와, 안정성과 빠른 서비스 성장을 위한 MSA, Service Mesh 환경을 어떻게 활용하고 운영하고 있는지 공유합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_22.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김동진/하성준",
      "shortDescription": "토스뱅크 DevOps Engineer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27416",
    "title": "어떻게 안정적인 서비스를 빠르게, 자주 출시할 것인가?",
    "subtitle": "토스페이먼츠는 가맹점이 빠르게 변화하는 시장에서 승리할 수 있도록, 사업자가 필요한 기능을 적시에 안정적으로 제공하는 것을 목표로 합니다. 안정적인 서비스를 빠르게, 자주 출시하기 위한 노력과 그로부터 얻은 러닝을 공유합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_21.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "하태호",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "DevOps"
        },
        {
          "content": "Server"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27290",
    "title": "토스 앱 오픈시간 1초를 줄이기까지",
    "subtitle": "토스 앱을 켜는 시간 1초를 줄이기까지의 과정과 시행착오를 소개합니다. ",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_4.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이종현",
      "shortDescription": "토스 Android Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH22"
        },
        {
          "content": "Android"
        }
      ]
    }
  },
  {
    "key": "27288",
    "title": "UX와 DX, 그 모든 경험을 위한 디자인 시스템",
    "subtitle": "토스 디자인 플랫폼 팀은 단순히 UI 요소를 개발하고, 컴포넌트화하는 것 이상의 디자인 시스템을 꿈꿉니다.\n더 좋은 사용자 경험을 제공하기 위한 크고 작은 고민들이 개발자 경험 곳곳에 어떤 모습으로 스며들었는지 공유합니다. ",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_3.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "박민수",
      "shortDescription": "토스 Android Developer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH22"
        },
        {
          "content": "Design System"
        },
        {
          "content": "Android"
        }
      ]
    }
  },
  {
    "key": "27286",
    "title": "미친 생산성을 위한 React Native",
    "subtitle": "토스 글로벌 팀이 React Native를 선택한 이유와 그 과정에 대해 소개합니다. ",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_2.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "오진성/이현수",
      "shortDescription": "토스 iOS Developer/Frontend Platform Engineer"
    },
    "shortDescription": "\n \n",
    "fullDescription": "\n \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "React Native"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27284",
    "title": "UIKit으로 만들어진 토스 디자인 시스템 SwiftUI에서 쓸 수 있을까? ",
    "subtitle": "UIKit로 만들어진 토스 디자인 시스템을 SwiftUI에서 사용할 수 있을까요? 토스 디자인 시스템을 사용하는 방법의 과거와 현재 그리고 미래를 소개합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "강준구",
      "shortDescription": "토스증권 iOS Developer"
    },
    "shortDescription": "",
    "fullDescription": "",
    "seoConfig": {
      "tags": [
        {
          "content": "iOS"
        },
        {
          "content": "SLASH22"
        },
        {
          "content": "Design System"
        }
      ]
    }
  },
  {
    "key": "27228",
    "title": "토스증권 실시간 시세 적용기",
    "subtitle": "토스증권에서 실시간으로 시세 정보를 제공하기 위한 시스템을 개발하면서 겪었던 이슈들과 안정화 과정을 소개합니다.",
    "publishedTime": "2022-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_13.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "박성우",
      "shortDescription": "토스증권 Server Developer"
    },
    "shortDescription": "",
    "fullDescription": "",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "kotlin-result",
    "title": "에러 핸들링을 다른 클래스에게 위임하기 (Kotlin 100% 활용)",
    "subtitle": "Kotlin의 Result로 MSA에서 에러가 전파되지 않는 안전한 환경을 만드는 방법을 알아봅니다.",
    "publishedTime": "2022-05-14T23:38:16+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/05/techblog-09-error-handling.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/05/techblog-09-error-handling.png"
    },
    "editor": {
      "name": "한규주",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "TL;DR\nResult를 이해한다면, MSA 환경에서 에러가 전파되지 않도록 막을 수 있습니다.\nrunCatching과 Result를 사용하면 에러 핸들링을 클라이언트에게 위임할 수 있습니다.\n예제: 로그인 요청을 전달하는 서비스 흐름에서 에러 처리하기\n아래와 같은 서비스 호출 흐름이 있다고 가정해보겠습니다.\n\nServe",
    "fullDescription": "TL;DR\nResult를 이해한다면, MSA 환경에서 에러가 전파되지 않도록 막을 수 있습니다.\nrunCatching과 Result를 사용하면 에러 핸들링을 클라이언트에게 위임할 수 있습니다.\n예제: 로그인 요청을 전달하는 서비스 흐름에서 에러 처리하기\n아래와 같은 서비스 호출 흐름이 있다고 가정해보겠습니다.\n\nServe",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "MSA"
        },
        {
          "content": "Kotlin"
        }
      ]
    }
  },
  {
    "key": "kotlin-dsl-restdocs",
    "title": "Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기",
    "subtitle": "토스페이먼츠에서는 API docs를 REST Docs를 사용해서 작성할 수 있도록 권장하고 있습니다. 이 글에서는 DSL을 통해서 반복적인 REST Docs 테스트 코드 작성을 줄일 수 있는 방법을 알아봅니다.",
    "publishedTime": "2022-04-11T05:24:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/04/techblog-08-rest-docs.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/04/techblog-08-rest-docs.png"
    },
    "editor": {
      "name": "한규주",
      "shortDescription": "토스페이먼츠 Server Developer"
    },
    "shortDescription": "REST Docs 테스트 코드량을 70% 줄여주는 DSL 개발기\n읽는 데 걸리는 시간: 6분\nDSL\nDomain Specific Languages(DSL)은 코드의 내부 로직을 숨기고 재사용성을 올려줍니다. 어떤 경우는 비 개발자가 사용하도록 고안되는 경우도 있어서, 일반적인 프로그래밍 언어보다 훨씬 쉬운 사용성을 가집니",
    "fullDescription": "REST Docs 테스트 코드량을 70% 줄여주는 DSL 개발기\n읽는 데 걸리는 시간: 6분\nDSL\nDomain Specific Languages(DSL)은 코드의 내부 로직을 숨기고 재사용성을 올려줍니다. 어떤 경우는 비 개발자가 사용하도록 고안되는 경우도 있어서, 일반적인 프로그래밍 언어보다 훨씬 쉬운 사용성을 가집니",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "Spring"
        },
        {
          "content": "Kotlin"
        }
      ]
    }
  },
  {
    "key": "faster-initial-rendering",
    "title": "조금만 신경써서 초기 렌더링 빠르게 하기 (feat. JAM Stack)",
    "subtitle": "SPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다.",
    "publishedTime": "2022-02-09T14:25:46+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/02/techblog-07-jam-stack.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2022/02/techblog-07-jam-stack.png"
    },
    "editor": {
      "name": "한재엽",
      "shortDescription": "토스페이먼츠 Frontend Developer"
    },
    "shortDescription": "들어가면서\nSPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다. 이번 개선은 Web Vitals 지표를 중심으로 측",
    "fullDescription": "들어가면서\nSPA(Single Page Application) 구조로 웹 프론트엔드 애플리케이션이 개발되면서 초기 렌더링 속도는 프런트엔드 개발자에게 중요한 과제 중 하나가 되었습니다. 사용자 경험에 영향을 줄 수 있는 가장 큰 요소 중 하나가 바로 속도이기 때문입니다. 이번 개선은 Web Vitals 지표를 중심으로 측",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "dev-agility",
    "title": "개발자의 애질리티",
    "subtitle": "이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다. 애자일하게 일한다는 것은 어떠한 의미일까요?",
    "publishedTime": "2021-10-14T22:32:16+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/10/techblog-06-agility.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/10/techblog-06-agility.png"
    },
    "editor": {
      "name": "강병훈",
      "shortDescription": "토스페이먼츠 Head of Technology"
    },
    "shortDescription": "이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다.\n애자일하게 일하기\n애자일하게 일한다는 것은 어떠한 의미일까요? 한 시간을 일하면 한 시간 만큼의 가치를 만들어 내는 방식이 아닐까 합니다. 예를 들어, 동작하는 함수를 구현하거나 난해한 개념을 이해하는 식으로요. \nBig up-f",
    "fullDescription": "이 글은 토스페이먼츠에 입사하신, 혹은 입사를 고려 중인 개발자분들을 위해 작성된 글입니다.\n애자일하게 일하기\n애자일하게 일한다는 것은 어떠한 의미일까요? 한 시간을 일하면 한 시간 만큼의 가치를 만들어 내는 방식이 아닐까 합니다. 예를 들어, 동작하는 함수를 구현하거나 난해한 개념을 이해하는 식으로요. \nBig up-f",
    "seoConfig": {
      "tags": [
        {
          "content": "문화"
        },
        {
          "content": "Agility"
        }
      ]
    }
  },
  {
    "key": "27414",
    "title": "Java Native Memory Leak 원인을 찾아서",
    "subtitle": "서버 프로세스가 내려갔을 때 코드와 Java 모니터링으로 원인을 못 찾는다면 어떻게 해야 할까요? 생각만 해도 막막한 이 순간, 원인을 찾아가는 과정을 공유합니다.",
    "publishedTime": "2021-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_20.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "박동호",
      "shortDescription": "토스페이먼츠 Server Platform Team Leader"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "SLASH22"
        },
        {
          "content": "Java"
        }
      ]
    }
  },
  {
    "key": "27412",
    "title": "iOS앱을 매주 배포 한다고?",
    "subtitle": "개선되거나 새로운 제품을 유저가 가장 빠르게 사용할 수 있도록, 앱 배포를 매주하는 개발자의 시간을 아껴주는 자동화 방법을 소개합니다.",
    "publishedTime": "2021-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_18.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김준모",
      "shortDescription": "토스 Engineering Director (Client Platform)"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "iOS"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27410",
    "title": "토스에서는 테이블 정보를 어떻게 관리하나요?",
    "subtitle": "서비스가 성장하면서 만들어지는 다양한 데이터와 수많은 테이블을 효율적으로 관리하고 활용하는 방법을 공유합니다.",
    "publishedTime": "2021-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_17.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "윤아서",
      "shortDescription": "토스 Data Engineer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Data"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "27408",
    "title": "물 흐르듯 자연스러운 ML 서비스 만들기",
    "subtitle": "회사마다 다른 AI, ML 적용 방식. 토스에서는 어떻게 사용하고 있을까요? 대규모 서비스에 최적화된 기술 스택과 인프라를 기반으로 머신러닝 서비스를 만들고 배포하는 과정을 공유합니다.",
    "publishedTime": "2021-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_16.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "고석현",
      "shortDescription": "토스 Machine Learning Engineer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "AI"
        },
        {
          "content": "SLASH22"
        },
        {
          "content": "Machine Learning"
        }
      ]
    }
  },
  {
    "key": "27406",
    "title": "토스팀 인프라 자동화의 시작",
    "subtitle": "운영 업무 시간을 90% 절약한 토스의 물리적 인프라 자동화 방법을 공유합니다.",
    "publishedTime": "2021-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_15.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김정남",
      "shortDescription": "토스 InfraOps Engineer"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "자동화"
        },
        {
          "content": "SLASH22"
        },
        {
          "content": "InfraOps"
        }
      ]
    }
  },
  {
    "key": "27402",
    "title": "잃어버린 개발자의 시간을 찾아서: 매일 하루를 아끼는 DevOps 이야기",
    "subtitle": "서비스가 지속적으로 최고의 사용자 경험을 제공하기 위해서는 개발자 경험(DX)이 뒷받침되어야 합니다. 토스에서 SSR을 도입하면서 겪었던 개발자 경험의 다양한 어려움과 이를 수호하기 위한 해결법을 공유합니다.",
    "publishedTime": "2021-06-08T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/list_thumbnail_19.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": " \n",
    "fullDescription": " \n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH22"
        }
      ]
    }
  },
  {
    "key": "template-literal-types",
    "title": "Template Literal Types로 타입 안전하게 코딩하기",
    "subtitle": "TypeScript 코드베이스의 타입 안전성을 한 단계 올려줄 수 있는 Template Literal Type의 뜻과 응용에 대해 알아봅니다.",
    "publishedTime": "2021-05-14T15:26:37+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/05/techblog-05-template-literal.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/05/techblog-05-template-literal.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "2020년 11월 TypeScript 4.1이 출시되면서 \"Template Literal Type\"을 사용할 수 있게 되었습니다. TypeScript로 JSON Parser를 만들거나, document.querySelector 의 결과 타입을 추론할 수 있게 되어 화제가 되었는데요. 이번 아티클에서는 Template Li",
    "fullDescription": "2020년 11월 TypeScript 4.1이 출시되면서 \"Template Literal Type\"을 사용할 수 있게 되었습니다. TypeScript로 JSON Parser를 만들거나, document.querySelector 의 결과 타입을 추론할 수 있게 되어 화제가 되었는데요. 이번 아티클에서는 Template Li",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "Frontend"
        },
        {
          "content": "TypeScript"
        }
      ]
    }
  },
  {
    "key": "node-modules-and-yarn-berry",
    "title": "node_modules로부터 우리를 구원해 줄 Yarn Berry",
    "subtitle": "토스 프론트엔드 레포지토리 대부분에서 사용하고 있는 패키지 매니저 Yarn Berry. 채택하게 된 배경과 사용하면서 좋았던 점을 공유합니다.",
    "publishedTime": "2021-05-07T17:18:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/05/techblog-04-yarn-berry.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/05/techblog-04-yarn-berry.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "토스 프론트엔드 챕터에서는 지난해부터 의존성을 관리하기 위해 Yarn Berry(v2)를 도입했습니다. 처음에는 일부 레포지토리부터 시작하여, 현재는 대부분의 레포지토리에 Yarn Berry가 적용되어 있는데요. 토스팀이 새로운 패키지 관리 시스템을 도입하게 된 배경과 사용하면서 좋았던 점을 테크 블로그를 통해 공유합니다",
    "fullDescription": "토스 프론트엔드 챕터에서는 지난해부터 의존성을 관리하기 위해 Yarn Berry(v2)를 도입했습니다. 처음에는 일부 레포지토리부터 시작하여, 현재는 대부분의 레포지토리에 Yarn Berry가 적용되어 있는데요. 토스팀이 새로운 패키지 관리 시스템을 도입하게 된 배경과 사용하면서 좋았던 점을 테크 블로그를 통해 공유합니다",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "jscodeshift",
    "title": "JSCodeShift로 기술 부채 청산하기",
    "subtitle": "기술 부채는 개발할수록 쌓여만 갑니다. 프론트엔드 챕터가 JSCodeShift를 이용하여 순식간에 100개 서비스의 기술 부채를 해결한 경험을 소개합니다.",
    "publishedTime": "2021-05-04T17:16:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/05/techblog-03-jscodeshift.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/05/techblog-03-jscodeshift.png"
    },
    "editor": {
      "name": "박지우",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "토스 프론트엔드 챕터에서는 100개 이상의 서비스들이 작은 패키지 단위로 쪼개져 활발하게 개발되고 있는데요. 공통으로 사용하는 라이브러리에서 인터페이스가 변경되는 Breaking Change가 발생하면, 의존하고 있는 모든 서비스의 코드를 수정해야 했습니다. 관리하는 코드베이스가 점점 커지면서 해야 하는 작업의 양도 계속",
    "fullDescription": "토스 프론트엔드 챕터에서는 100개 이상의 서비스들이 작은 패키지 단위로 쪼개져 활발하게 개발되고 있는데요. 공통으로 사용하는 라이브러리에서 인터페이스가 변경되는 Breaking Change가 발생하면, 의존하고 있는 모든 서비스의 코드를 수정해야 했습니다. 관리하는 코드베이스가 점점 커지면서 해야 하는 작업의 양도 계속",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "smart-web-service-cache",
    "title": "웹 서비스 캐시 똑똑하게 다루기",
    "subtitle": "웹 성능을 위해 꼭 필요한 캐시, 제대로 설정하기 쉽지 않습니다. 토스 프론트엔드 챕터에서 올바르게 캐시를 설정하기 위한 노하우를 공유합니다.",
    "publishedTime": "2021-04-29T17:08:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/04/techblog-02-webcash.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/04/techblog-02-webcash.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "토스 프론트엔드 챕터에서는 웹 성능을 최대한으로 높이기 위해 HTTP 캐시를 적극적으로 사용하고 있습니다. 캐시를 잘못 관리했을 때, 원하는 시점에 캐시가 사라지지 않을 수 있습니다. 필요 이상으로 HTTP 요청이 발생하기도 합니다.\nHTTP 캐시를 효율적으로 관리하려면 Cache-Control 헤더를 섬세하게 조절해야 ",
    "fullDescription": "토스 프론트엔드 챕터에서는 웹 성능을 최대한으로 높이기 위해 HTTP 캐시를 적극적으로 사용하고 있습니다. 캐시를 잘못 관리했을 때, 원하는 시점에 캐시가 사라지지 않을 수 있습니다. 필요 이상으로 HTTP 요청이 발생하기도 합니다.\nHTTP 캐시를 효율적으로 관리하려면 Cache-Control 헤더를 섬세하게 조절해야 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  },
  {
    "key": "27324",
    "title": "MYSQL HA & DR Topology",
    "subtitle": "토스의 Database DR 구조에 대해 공유합니다.",
    "publishedTime": "2021-04-28T15:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_김피터.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김피터",
      "shortDescription": "토스 DBA Team Leader"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Data"
        },
        {
          "content": "SLASH21"
        },
        {
          "content": "MySQL"
        }
      ]
    }
  },
  {
    "key": "27448",
    "title": "토스팀을 위한 슬랙봇 설계",
    "subtitle": "토스에서 사용하는 슬랙봇들의 개발 과정과 그동안의 고민을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_임한솔.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "임한솔",
      "shortDescription": "토스 Full Stack Developer"
    },
    "shortDescription": "\n\n\n",
    "fullDescription": "\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH21"
        },
        {
          "content": "Full Stack"
        },
        {
          "content": "Slack"
        }
      ]
    }
  },
  {
    "key": "27446",
    "title": "프론트엔드 웹 서비스에서 우아하게 비동기 처리하기",
    "subtitle": "API를 호출하거나 네이티브 앱과 통신할 때 프론트엔드 웹 서비스에서는 반드시 비동기 작업이 일어나게 됩니다. 일상처럼 다루고 있지만 정작 UI에서 다루기 힘든 비동기 프로그래밍. React Suspense를 이용하여 우아하게 처리하는 이론과 실전 적용법을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_박서진.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "\n\n\n",
    "fullDescription": "\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27444",
    "title": "JavaScript Bundle Diet",
    "subtitle": "웹사이트 기능이 많아짐에 따라 점점 커지는 JavaScript Bundle Size. 웹사이트 속도는 느려지고, 잠재 고객을 잃을 수도 있습니다. 라이브러리를 사용하는 그리고 제공하는 관점에서 Bundle Size가 커질 수 있는 상황과 해결 방법을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이한.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이한",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "\n\n\n",
    "fullDescription": "\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "JavaScript"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27442",
    "title": "실무에서 바로 쓰는 Frontend Clean Code",
    "subtitle": "실무에서 클린 코드의 의의는 유지보수 시간의 단축입니다. 동료 혹은 과거의 스스로 짠 코드를 빠르게 이해할 수 있다면 유지보수할 때 드는 개발 시간이 짧아집니다. 실제 예시와 함께 1. 응집도 2. 단일 책임 3. 추상화 총 세 가지 관점으로 클린코드 방법론을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_진유림.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "진유림",
      "shortDescription": "토스 Frontend Developer"
    },
    "shortDescription": "\n\n\n\n\n",
    "fullDescription": "\n\n\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27440",
    "title": "TDS로 UI 쌓기: 그 많던 코드는 누가 다 치웠을까?",
    "subtitle": "TDS(Toss Design System)로 구성되어 있는 토스의 제품들. 복잡한 화면도 단숨에 개발할 수 있도록 큰 힘이 되어주는 TDS를 개발자들이 사용하고, 확장하는 과정을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_박민수.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "박민수",
      "shortDescription": "토스 Android Developer"
    },
    "shortDescription": "\n\n\n",
    "fullDescription": "\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "Design System"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27438",
    "title": "Build, Harder Better Faster Stronger",
    "subtitle": "프로젝트가 복잡해지고 커져감에 따라 일반적인 빌드 방법으로는 더 이상 빨라지지 않는 지점이 옵니다. 토스에서 해당 지점을 넘어 더 빠른 개발 속도를 달성한 방법을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이성민.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이성민",
      "shortDescription": "토스 Android Developer"
    },
    "shortDescription": "\n\n\n",
    "fullDescription": "\n\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27436",
    "title": "Micro-frontend React, 점진적으로 도입하기",
    "subtitle": "거대한 모놀리식 Django 프로젝트에 현대적인 프론트엔드 인프라를 구축한 사례를 공유합니다. 어떻게 해야 오래된 코드 베이스를 대대적으로 수정하지 않으면서도, 최신 프론트엔드 기술들을 적극적으로 도입해나갈 수 있을지 고민한 경험을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_조유성.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "조유성",
      "shortDescription": "토스 Frontend UX Engineer"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        },
        {
          "content": "SLASH21"
        },
        {
          "content": "Django"
        }
      ]
    }
  },
  {
    "key": "27326",
    "title": "토스뱅크 데이터 설계사상",
    "subtitle": "토스뱅크의 데이터 설계가 어떻게 진행되었는지 다른 은행과의 비교를 통해 그 과정을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_조한기.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "조한기",
      "shortDescription": "토스뱅크 Server Developer"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Data"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27322",
    "title": "빠르게 성장하는 스타트업의 DW",
    "subtitle": "빠르게 성장하는 회사에서 제한된 리소스 안에서 데이터를 효율적으로 집계하고 제공하기 위해 선택한 방법. 신뢰할 수 있는 데이터 제공 및 데이터의 맥락, 정보 공유를 위한 고민들과 이를 극복하기 위한 방법을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_유승민.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "유승민",
      "shortDescription": "토스 Data Mart Team Leader"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Data"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27320",
    "title": "토스 데이터의 흐름과 활용",
    "subtitle": "토스의 데이터 흐름과 활용 방법, 그리고 용도에 따라 어떤 플랫폼을 활용하는지를 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_유결.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "유결",
      "shortDescription": "토스 Data Platform Team Leader"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "플랫폼"
        },
        {
          "content": "Data"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27318",
    "title": "결제 시스템의 SDK와 API 디자인",
    "subtitle": "PG 연동 개발자들에게 쉽고 빠른 가이드 제공을 위해, 20년 동안 유지된 기존 시스템에 추상화 레이어를 만들고 SDK와 API를 설계했던 경험을 공유합니다. 추가로 인터페이스의 일관성과 예측 가능성 그리고 TypeScript와 npm 모듈 지원을 위한 시도들까지, 토스페이먼츠 오픈 API의 첫 여정에 대해 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이홍채.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이홍채/이현섭/박순영",
      "shortDescription": "토스페이먼츠 Developer Product Team"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Product Design"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27316",
    "title": "테스트 커버리지 100%",
    "subtitle": "스프링 프레임워크 기반 서버 애플리케이션을 코틀린으로 작성하면서, 테스트 커버리지를 100%까지 올리고 1년 6개월 동안 유지해보았습니다. 이 경험을 통해 배운 점과 테스트 개선 방법에 대한 고민을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이응준.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이응준",
      "shortDescription": null
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "테스트"
        },
        {
          "content": "Server"
        },
        {
          "content": "Spring"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27314",
    "title": "실수 없이 안전하게 쿠버네티스 운영하기",
    "subtitle": "효율적인 쿠버네티스 관리를 통해 휴먼 에러를 방지하는 방법을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_김형록.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "김형록",
      "shortDescription": "토스 DevOps Engineer"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH21"
        },
        {
          "content": "Kubernetes"
        }
      ]
    }
  },
  {
    "key": "27312",
    "title": "SRE 사례 소개",
    "subtitle": "토스에서 경험한 사이트 신뢰성 엔지니어링 사례를 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_조규희.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "조규희",
      "shortDescription": "토스 Engineering Director (SRE)"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "SLASH21"
        },
        {
          "content": "SRE"
        }
      ]
    }
  },
  {
    "key": "27310",
    "title": "토스 서비스를 구성하는 서버 기술",
    "subtitle": "Active-Active 데이터센터 운영, Kubernetes와 Istio Service Mesh 운영, API-Gateway, Kafka, Redis, Monitoring Stack 등 토스에서 사용하는 전반적인 기술과 시스템 구성을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이항령.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "이항령",
      "shortDescription": "토스 Head of Server"
    },
    "shortDescription": "\n\n",
    "fullDescription": "\n\n",
    "seoConfig": {
      "tags": [
        {
          "content": "Server"
        },
        {
          "content": "Kafka"
        },
        {
          "content": "SLASH21"
        },
        {
          "content": "Kubernetes"
        }
      ]
    }
  },
  {
    "key": "27308",
    "title": "토스의 서버 인프라 모니터링",
    "subtitle": "서버 인프라를 효과적으로 트러블 슈팅할 수 있도록 노력한 경험과 모니터링 인프라를 운영한 경험을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이재성.png"
    },
    "coverConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_이재성.png"
    },
    "editor": {
      "name": "이재성",
      "shortDescription": "토스 DevOps Team Leader"
    },
    "shortDescription": "",
    "fullDescription": "",
    "seoConfig": {
      "tags": [
        {
          "content": "DevOps"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "27306",
    "title": "메모리에 남지 않는 문자열",
    "subtitle": "메모리에 남지 않는 문자열을 통해 민감한 정보를 안전하게 사용하는 방법을 공유합니다.",
    "publishedTime": "2021-04-28T10:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://static.toss.im/career-resource/slash21_안정원.png"
    },
    "coverConfig": {
      "imageUrl": null
    },
    "editor": {
      "name": "안정원",
      "shortDescription": "토스 Server Developer"
    },
    "shortDescription": "",
    "fullDescription": "",
    "seoConfig": {
      "tags": [
        {
          "content": "Security"
        },
        {
          "content": "iOS"
        },
        {
          "content": "SLASH21"
        }
      ]
    }
  },
  {
    "key": "toss-frontend-chapter",
    "title": "토스 프론트엔드 챕터를 소개합니다!",
    "subtitle": "토스에서 프론트엔드 개발자가 일하는 방법과 맡고 있는 역할에 대해 소개드립니다.",
    "publishedTime": "2021-04-28T08:00:00+09:00",
    "category": "개발",
    "thumbnailConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/04/techblog-01-about-fechapter.png"
    },
    "coverConfig": {
      "imageUrl": "https://wp.toss.tech/wp-content/uploads/2021/04/techblog-01-about-fechapter.png"
    },
    "editor": {
      "name": "박서진",
      "shortDescription": "토스 Head of Frontend"
    },
    "shortDescription": "안녕하세요. 토스 프론트엔드 챕터 블로그에 오신 것을 환영합니다. 앞으로 토스팀에서 프론트엔드 개발을 하면서 생기는 이야기들을 정리하여 블로그로 전해드리려고 합니다.\n\n토스 프론트엔드 챕터는?\n토스에서는 같은 일을 하는 사람들을 모아서 챕터라고 합니다. 프론트엔드 챕터는 JavaScript, HTML, CSS를 이용하여 ",
    "fullDescription": "안녕하세요. 토스 프론트엔드 챕터 블로그에 오신 것을 환영합니다. 앞으로 토스팀에서 프론트엔드 개발을 하면서 생기는 이야기들을 정리하여 블로그로 전해드리려고 합니다.\n\n토스 프론트엔드 챕터는?\n토스에서는 같은 일을 하는 사람들을 모아서 챕터라고 합니다. 프론트엔드 챕터는 JavaScript, HTML, CSS를 이용하여 ",
    "seoConfig": {
      "tags": [
        {
          "content": "Frontend"
        }
      ]
    }
  }
]